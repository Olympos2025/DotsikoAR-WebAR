<!DOCTYPE html>

<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>MapLens - Location AR Viewer</title>

```
<!-- A-Frame and AR.js -->
<script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/three.js/build/ar-threex-location-only.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.js"></script>
<script src="https://unpkg.com/@tmcw/togeojson@5.8.1"></script>

<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        overflow: hidden;
        background: #000;
        height: 100vh;
        width: 100vw;
        position: fixed;
    }

    /* Controls */
    .controls {
        position: fixed;
        top: calc(env(safe-area-inset-top, 10px) + 10px);
        left: 10px;
        right: 10px;
        display: flex;
        gap: 8px;
        justify-content: center;
        z-index: 9999;
        flex-wrap: wrap;
    }

    .btn {
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        font-weight: 600;
        font-size: 12px;
        cursor: pointer;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        white-space: nowrap;
        min-height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .btn-primary { background: rgba(59, 130, 246, 0.9); }
    .btn-success { background: rgba(16, 185, 129, 0.9); }
    .btn-danger { background: rgba(239, 68, 68, 0.9); }

    .file-input {
        position: absolute;
        left: -9999px;
        opacity: 0;
        width: 0.1px;
        height: 0.1px;
    }

    /* Status */
    .status {
        position: fixed;
        top: calc(env(safe-area-inset-top, 10px) + 60px);
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 8px;
        padding: 8px;
        z-index: 9998;
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: calc(100vw - 20px);
    }

    .status-item {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 4px;
        font-size: 11px;
        color: white;
        white-space: nowrap;
    }

    .status-item:last-child { margin-bottom: 0; }

    .status-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #ef4444;
        flex-shrink: 0;
    }

    .status-dot.active {
        background: #10b981;
        box-shadow: 0 0 8px #10b981;
    }

    /* Info */
    .info {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 10px) + 10px);
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(15px);
        border-radius: 8px;
        padding: 12px;
        color: white;
        font-size: 13px;
        z-index: 9997;
        transform: translateY(calc(100% + 20px));
        transition: transform 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-height: calc(40vh - env(safe-area-inset-bottom, 0px) - 20px);
        overflow-y: auto;
    }

    .info.show { transform: translateY(0); }

    /* Debug */
    .debug {
        position: fixed;
        top: calc(env(safe-area-inset-top, 10px) + 120px);
        left: 10px;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        border-radius: 6px;
        padding: 6px;
        font-family: monospace;
        font-size: 9px;
        color: #00ff00;
        z-index: 9996;
        display: none;
        border: 1px solid rgba(0, 255, 0, 0.3);
        max-width: calc(100vw - 20px);
    }

    .debug.show { display: block; }

    .debug div {
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* A-Frame scene */
    a-scene {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        z-index: 1 !important;
    }

    /* Loading indicator */
    .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 16px;
        z-index: 9999;
        display: none;
        text-align: center;
    }

    .spinner {
        width: 30px;
        height: 30px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 8px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Error dialog */
    .error-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(239, 68, 68, 0.95);
        color: white;
        padding: 16px;
        border-radius: 8px;
        text-align: center;
        z-index: 10000;
        max-width: calc(100vw - 40px);
        max-height: calc(100vh - 40px);
        overflow-y: auto;
        display: none;
    }

    .error-dialog h3 {
        margin-bottom: 10px;
        font-size: 16px;
    }

    .error-dialog p {
        margin-bottom: 15px;
        font-size: 14px;
        line-height: 1.4;
    }

    .error-dialog button {
        padding: 8px 16px;
        background: white;
        color: #ef4444;
        border: none;
        border-radius: 4px;
        font-weight: 600;
        cursor: pointer;
        font-size: 14px;
    }

    /* Mobile specific adjustments */
    @media (max-width: 480px) {
        .controls {
            gap: 6px;
        }
        
        .btn {
            padding: 6px 10px;
            font-size: 11px;
            min-height: 32px;
        }
        
        .status {
            top: calc(env(safe-area-inset-top, 10px) + 50px);
            padding: 6px;
        }
        
        .status-item {
            font-size: 10px;
            margin-bottom: 3px;
        }
        
        .debug {
            top: calc(env(safe-area-inset-top, 10px) + 100px);
            font-size: 8px;
            padding: 4px;
        }
        
        .info {
            font-size: 12px;
            padding: 10px;
        }
    }

    /* Landscape orientation adjustments */
    @media (orientation: landscape) and (max-height: 500px) {
        .controls {
            top: calc(env(safe-area-inset-top, 5px) + 5px);
            gap: 4px;
        }
        
        .btn {
            padding: 4px 8px;
            font-size: 10px;
            min-height: 28px;
        }
        
        .status {
            top: calc(env(safe-area-inset-top, 5px) + 35px);
            padding: 4px;
        }
        
        .status-item {
            font-size: 9px;
            margin-bottom: 2px;
        }
        
        .info {
            max-height: calc(30vh - env(safe-area-inset-bottom, 0px) - 10px);
            font-size: 11px;
            padding: 8px;
        }
        
        .debug {
            top: calc(env(safe-area-inset-top, 5px) + 70px);
            font-size: 7px;
        }
    }

    /* iOS Safari specific fixes */
    @supports (-webkit-touch-callout: none) {
        body {
            /* Fix for iOS Safari viewport issues */
            height: -webkit-fill-available;
        }
        
        .info {
            /* Extra padding for iOS safe area */
            bottom: calc(env(safe-area-inset-bottom, 20px) + 10px);
        }
    }

    /* Hide elements that might overflow */
    .controls, .status, .info, .debug, .loading, .error-dialog {
        contain: layout;
    }
</style>
```

</head>

<body>
    <!-- Controls -->
    <div class="controls">
        <input type="file" id="kml-input" class="file-input" accept=".kml,.kmz" multiple>
        <label for="kml-input" class="btn btn-primary">üìÅ Œ¶œåœÅœÑœâœÉŒ∑ KML</label>
        <button id="debug-btn" class="btn">üîß Debug</button>
        <button id="clear-btn" class="btn btn-danger">üóëÔ∏è ŒöŒ±Œ∏Œ±œÅŒπœÉŒºœåœÇ</button>
    </div>

```
<!-- Status Panel -->
<div class="status">
    <div class="status-item">
        <span class="status-dot" id="camera-dot"></span>
        <span id="camera-text">ŒöŒ¨ŒºŒµœÅŒ±</span>
    </div>
    <div class="status-item">
        <span class="status-dot" id="gps-dot"></span>
        <span id="gps-text">GPS</span>
    </div>
    <div class="status-item">
        <span class="status-dot" id="orientation-dot"></span>
        <span id="orientation-text">Œ†œÅŒøœÉŒ±ŒΩŒ±œÑŒøŒªŒπœÉŒºœåœÇ</span>
    </div>
    <div class="status-item">
        <span class="status-dot" id="features-dot"></span>
        <span id="features-text">Œ£œÑŒøŒπœáŒµŒØŒ±: 0</span>
    </div>
</div>

<!-- Debug Panel -->
<div class="debug" id="debug-panel">
    <div>GPS: <span id="debug-gps">ŒëŒΩŒ±ŒºŒøŒΩŒÆ...</span></div>
    <div>Heading: <span id="debug-heading">ŒëŒΩŒ±ŒºŒøŒΩŒÆ...</span></div>
    <div>Accuracy: <span id="debug-accuracy">ŒëŒΩŒ±ŒºŒøŒΩŒÆ...</span></div>
    <div>Features: <span id="debug-features">0</span></div>
    <div>AR Objects: <span id="debug-objects">0</span></div>
</div>

<!-- Info Panel -->
<div class="info" id="info">
    ŒëœÅœáŒπŒ∫ŒøœÄŒøŒØŒ∑œÉŒ∑ MapLens...
</div>

<!-- Loading -->
<div class="loading" id="loading">
    <div class="spinner"></div>
    <div>Œ¶œåœÅœÑœâœÉŒ∑...</div>
</div>

<!-- Error Dialog -->
<div class="error-dialog" id="error-dialog">
    <h3>Œ£œÜŒ¨ŒªŒºŒ±</h3>
    <p id="error-text"></p>
    <button onclick="hideError()">OK</button>
</div>

<!-- AR Scene -->
<a-scene
    id="ar-scene"
    vr-mode-ui="enabled: false"
    arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
    renderer="logarithmicDepthBuffer: true; colorManagement: true; sortObjects: true; antialias: true; alpha: true;"
    embedded
    style="height: 100vh; width: 100vw;">
    
    <a-camera 
        id="ar-camera"
        gps-new-camera="gpsMinDistance: 1; gpsMaxDistance: 50000; positionMinAccuracy: 1000; alert: false; smoothingFactor: 0.05;"
        look-controls="enabled: false"
        wasd-controls="enabled: false"
        cursor="rayOrigin: mouse">
    </a-camera>
    
    <a-entity id="ar-objects"></a-entity>
</a-scene>

<script>
    class MapLensAR {
        constructor() {
            this.scene = document.getElementById('ar-scene');
            this.camera = document.getElementById('ar-camera');
            this.container = document.getElementById('ar-objects');
            this.features = [];
            this.userPosition = null;
            this.debugMode = false;
            
            this.init();
        }

        async init() {
            console.log('üöÄ MapLens AR initializing...');
            
            try {
                // Wait for scene to load
                await this.waitForScene();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Initialize location services
                this.initLocationServices();
                
                // Initialize orientation
                this.initOrientation();
                
                console.log('‚úÖ MapLens AR ready');
                this.showInfo('MapLens Œ≠œÑŒøŒπŒºŒø! Œ¶ŒøœÅœÑœéœÉœÑŒµ KML Œ±œÅœáŒµŒØŒø Œ≥ŒπŒ± ŒΩŒ± Œ¥ŒµŒØœÑŒµ AR œÉœÑŒøŒπœáŒµŒØŒ±. Œ£Œ•ŒúŒíŒüŒ•ŒõŒó: ŒíŒµŒ≤Œ±ŒπœâŒ∏ŒµŒØœÑŒµ œåœÑŒπ Œ≤œÅŒØœÉŒ∫ŒµœÉœÑŒµ Œ∫ŒøŒΩœÑŒ¨ œÉœÑŒ∑ŒΩ œÄŒµœÅŒπŒøœáŒÆ œÑœâŒΩ Œ¥ŒµŒ¥ŒøŒºŒ≠ŒΩœâŒΩ KML.');
                
            } catch (error) {
                console.error('‚ùå Initialization failed:', error);
                this.showError(`Œ£œÜŒ¨ŒªŒºŒ± Œ±œÅœáŒπŒ∫ŒøœÄŒøŒØŒ∑œÉŒ∑œÇ: ${error.message}`);
            }
        }

        waitForScene() {
            return new Promise((resolve) => {
                if (this.scene.hasLoaded) {
                    resolve();
                } else {
                    this.scene.addEventListener('loaded', resolve);
                }
            });
        }

        setupEventListeners() {
            // File input
            document.getElementById('kml-input').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    this.loadKMLFiles(e.target.files);
                }
            });

            // Debug toggle
            document.getElementById('debug-btn').addEventListener('click', () => {
                this.debugMode = !this.debugMode;
                document.getElementById('debug-panel').classList.toggle('show', this.debugMode);
                if (this.debugMode) {
                    this.updateDebugInfo();
                }
            });

            // Clear button
            document.getElementById('clear-btn').addEventListener('click', () => {
                this.clearAll();
            });

            // Scene events
            this.scene.addEventListener('enter-vr', () => {
                console.log('AR mode entered');
                this.updateStatus('camera', true, 'ŒöŒ¨ŒºŒµœÅŒ±: ŒïŒΩŒµœÅŒ≥ŒÆ');
            });

            this.scene.addEventListener('exit-vr', () => {
                console.log('AR mode exited');
            });

            // Camera ready detection
            this.scene.addEventListener('loaded', () => {
                console.log('üìπ Scene loaded, checking camera...');
                setTimeout(() => {
                    // Check if camera stream is active
                    const video = document.querySelector('video');
                    if (video && video.videoWidth > 0) {
                        console.log('‚úÖ Camera stream active');
                        this.updateStatus('camera', true, 'ŒöŒ¨ŒºŒµœÅŒ±: ŒïŒΩŒµœÅŒ≥ŒÆ');
                    } else {
                        console.log('‚ùå Camera stream not detected');
                        this.updateStatus('camera', false, 'ŒöŒ¨ŒºŒµœÅŒ±: Œ£œÜŒ¨ŒªŒºŒ±');
                    }
                }, 3000);
            });

            // Listen for camera permission events
            this.scene.addEventListener('camera-init', () => {
                console.log('üìπ Camera initializing...');
                this.updateStatus('camera', false, 'ŒöŒ¨ŒºŒµœÅŒ±: ŒëœÅœáŒπŒ∫ŒøœÄŒøŒØŒ∑œÉŒ∑...');
            });

            this.scene.addEventListener('camera-error', (event) => {
                console.error('‚ùå Camera error:', event);
                this.updateStatus('camera', false, 'ŒöŒ¨ŒºŒµœÅŒ±: Œ£œÜŒ¨ŒªŒºŒ±');
                this.showError('Œ£œÜŒ¨ŒªŒºŒ± Œ∫Œ¨ŒºŒµœÅŒ±œÇ. Œ†Œ±œÅŒ±Œ∫Œ±Œªœé ŒµŒªŒ≠Œ≥ŒæœÑŒµ œÑŒπœÇ Œ¨Œ¥ŒµŒπŒµœÇ œÉœÑŒπœÇ œÅœÖŒ∏ŒºŒØœÉŒµŒπœÇ œÑŒøœÖ Safari.');
            });
        }

        async initLocationServices() {
            if (!navigator.geolocation) {
                this.updateStatus('gps', false, 'GPS: ŒúŒ∑ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒø');
                this.showError('GPS Œ¥ŒµŒΩ œÖœÄŒøœÉœÑŒ∑œÅŒØŒ∂ŒµœÑŒ±Œπ œÉŒµ Œ±œÖœÑŒÆ œÑŒ∑ œÉœÖœÉŒ∫ŒµœÖŒÆ');
                return;
            }

            // Request permission first
            try {
                console.log('üìç Requesting GPS permission...');
                this.updateStatus('gps', false, 'GPS: ŒëŒØœÑŒ∑œÉŒ∑ Œ¨Œ¥ŒµŒπŒ±œÇ...');
                
                const options = {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 5000
                };

                // Get position once to trigger permission
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, options);
                });
                
                console.log('‚úÖ GPS permission granted, starting watch...');
                this.handleGPSSuccess(position);
                
                // Now start watching
                this.gpsWatchId = navigator.geolocation.watchPosition(
                    (position) => this.handleGPSSuccess(position),
                    (error) => this.handleGPSError(error),
                    options
                );

            } catch (error) {
                console.error('‚ùå GPS permission error:', error);
                this.handleGPSError(error);
            }
        }

        handleGPSSuccess(position) {
            this.userPosition = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                altitude: position.coords.altitude || 0,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp
            };

            this.updateStatus('gps', true, `GPS: ¬±${Math.round(position.coords.accuracy)}m`);

            if (this.debugMode) {
                document.getElementById('debug-gps').textContent = 
                    `${this.userPosition.latitude.toFixed(6)}, ${this.userPosition.longitude.toFixed(6)}`;
                document.getElementById('debug-accuracy').textContent = 
                    `¬±${Math.round(position.coords.accuracy)}m`;
            }

            console.log('üìç GPS updated:', this.userPosition);
        }

        handleGPSError(error) {
            console.error('‚ùå GPS error:', error);
            
            let message = 'GPS: Œ£œÜŒ¨ŒªŒºŒ±';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message = 'GPS: ŒëœÄŒøœÅœÅŒØœÜŒ∏Œ∑Œ∫Œµ';
                    this.showError('Œ†Œ±œÅŒ±Œ∫Œ±Œªœé ŒµœÄŒπœÑœÅŒ≠œàœÑŒµ œÑŒ∑ŒΩ œÄœÅœåœÉŒ≤Œ±œÉŒ∑ œÉœÑŒ∑ŒΩ œÑŒøœÄŒøŒ∏ŒµœÉŒØŒ± œÉœÑŒπœÇ œÅœÖŒ∏ŒºŒØœÉŒµŒπœÇ œÑŒøœÖ Safari');
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = 'GPS: ŒúŒ∑ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒø';
                    break;
                case error.TIMEOUT:
                    message = 'GPS: Timeout';
                    break;
            }
            
            this.updateStatus('gps', false, message);
        }

        async initOrientation() {
            console.log('üß≠ Initializing orientation...');
            this.updateStatus('orientation', false, 'Œ†œÅŒøœÉŒ±ŒΩŒ±œÑŒøŒªŒπœÉŒºœåœÇ: ŒëŒØœÑŒ∑œÉŒ∑...');
            
            // Request permission for iOS 13+
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                
                try {
                    console.log('üì± Requesting iOS orientation permission...');
                    const response = await DeviceOrientationEvent.requestPermission();
                    
                    if (response === 'granted') {
                        console.log('‚úÖ iOS orientation permission granted');
                        this.setupOrientationListeners();
                    } else {
                        console.error('‚ùå iOS orientation permission denied');
                        this.updateStatus('orientation', false, 'Œ†œÅŒøœÉŒ±ŒΩŒ±œÑŒøŒªŒπœÉŒºœåœÇ: ŒëœÄŒøœÅœÅŒØœÜŒ∏Œ∑Œ∫Œµ');
                        this.showError('Œ†Œ±œÅŒ±Œ∫Œ±Œªœé ŒµœÄŒπœÑœÅŒ≠œàœÑŒµ œÑŒ∑ŒΩ œÄœÅœåœÉŒ≤Œ±œÉŒ∑ œÉœÑŒøŒΩ œÄœÅŒøœÉŒ±ŒΩŒ±œÑŒøŒªŒπœÉŒºœå œÉœÖœÉŒ∫ŒµœÖŒÆœÇ œÉœÑŒπœÇ œÅœÖŒ∏ŒºŒØœÉŒµŒπœÇ œÑŒøœÖ Safari');
                    }
                } catch (error) {
                    console.error('‚ùå Orientation permission error:', error);
                    this.updateStatus('orientation', false, 'Œ†œÅŒøœÉŒ±ŒΩŒ±œÑŒøŒªŒπœÉŒºœåœÇ: Œ£œÜŒ¨ŒªŒºŒ±');
                    this.showError(`Œ£œÜŒ¨ŒªŒºŒ± œÄœÅŒøœÉŒ±ŒΩŒ±œÑŒøŒªŒπœÉŒºŒøœç: ${error.message}`);
                }
            } else {
                // Android or older iOS
                console.log('ü§ñ Android/older iOS - setting up orientation listeners');
                this.setupOrientationListeners();
            }
        }

        setupOrientationListeners() {
            let hasReceived = false;

            const handleOrientation = (event) => {
                if (!hasReceived) {
                    hasReceived = true;
                    this.updateStatus('orientation', true, 'Œ†œÅŒøœÉŒ±ŒΩŒ±œÑŒøŒªŒπœÉŒºœåœÇ: ŒïŒΩŒµœÅŒ≥œåœÇ');
                }

                if (this.debugMode) {
                    const alpha = event.alpha || 0;
                    const beta = event.beta || 0;
                    const gamma = event.gamma || 0;
                    document.getElementById('debug-heading').textContent = 
                        `Œ±:${alpha.toFixed(1)}¬∞ Œ≤:${beta.toFixed(1)}¬∞ Œ≥:${gamma.toFixed(1)}¬∞`;
                }
            };

            // Listen to orientation events
            window.addEventListener('deviceorientationabsolute', handleOrientation, true);
            window.addEventListener('deviceorientation', handleOrientation, true);

            // Fallback timeout
            setTimeout(() => {
                if (!hasReceived) {
                    this.updateStatus('orientation', false, 'Œ†œÅŒøœÉŒ±ŒΩŒ±œÑŒøŒªŒπœÉŒºœåœÇ: Timeout');
                }
            }, 5000);

            console.log('üß≠ Orientation listeners setup');
        }

        async loadKMLFiles(files) {
            this.showLoading(true);
            let totalFeatures = 0;

            try {
                for (const file of files) {
                    console.log(`üìÅ Processing ${file.name}`);
                    const features = await this.parseKML(file);
                    
                    console.log(`üìÑ Parsed features:`, features);
                    
                    // Create AR objects for each feature
                    let createdObjects = 0;
                    features.forEach((feature, index) => {
                        console.log(`üéØ Creating AR object ${index + 1}/${features.length}:`, feature);
                        const success = this.createARObject(feature);
                        if (success) createdObjects++;
                    });
                    
                    console.log(`‚úÖ Created ${createdObjects}/${features.length} AR objects`);
                    
                    this.features.push(...features);
                    totalFeatures += features.length;
                }

                this.updateStatus('features', totalFeatures > 0, `Œ£œÑŒøŒπœáŒµŒØŒ±: ${totalFeatures}`);
                
                if (this.debugMode) {
                    document.getElementById('debug-features').textContent = totalFeatures;
                    document.getElementById('debug-objects').textContent = this.container.children.length;
                    
                    // Add detailed position info to debug
                    this.updateDebugInfo();
                }

                if (totalFeatures > 0) {
                    const objectsCount = this.container.children.length;
                    this.showInfo(`‚úÖ Œ¶ŒøœÅœÑœéŒ∏Œ∑Œ∫Œ±ŒΩ ${totalFeatures} œÉœÑŒøŒπœáŒµŒØŒ±! ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒÆŒ∏Œ∑Œ∫Œ±ŒΩ ${objectsCount} AR objects. 
```

üîç ŒïŒªŒ≠Œ≥ŒæœÑŒµ œÑŒø Debug panel Œ≥ŒπŒ± ŒªŒµœÄœÑŒøŒºŒ≠œÅŒµŒπŒµœÇ Œ∏Œ≠œÉŒ∑œÇ.
üì± ŒöŒπŒΩŒ∑Œ∏ŒµŒØœÑŒµ Œ±œÅŒ≥Œ¨ Œ∫Œ±Œπ œÉœÑœÅŒ≠œàœÑŒµ œÑŒ∑ŒΩ Œ∫Œ¨ŒºŒµœÅŒ± Œ≥œçœÅœâ œÉŒ±œÇ.
üìè Œ§Œ± objects ŒµŒØŒΩŒ±Œπ ŒºŒµŒ≥Œ¨ŒªŒ± Œ∫Œ±Œπ œÜœâœÑŒµŒπŒΩŒ¨ Œ≥ŒπŒ± Œ∫Œ±ŒªœçœÑŒµœÅŒ∑ ŒøœÅŒ±œÑœåœÑŒ∑œÑŒ±.
‚ö†Ô∏è ŒëŒΩ Œ¥ŒµŒΩ œÑŒ± Œ≤ŒªŒ≠œÄŒµœÑŒµ, ŒµŒªŒ≠Œ≥ŒæœÑŒµ Œ±ŒΩ Œ≤œÅŒØœÉŒ∫ŒµœÉœÑŒµ Œ∫ŒøŒΩœÑŒ¨ œÉœÑŒ∑ŒΩ œÄŒµœÅŒπŒøœáŒÆ œÑœâŒΩ Œ¥ŒµŒ¥ŒøŒºŒ≠ŒΩœâŒΩ.`);

```
                    // Force update all AR objects
                    this.forceUpdateARObjects();
                } else {
                    this.showError('ŒîŒµŒΩ Œ≤œÅŒ≠Œ∏Œ∑Œ∫Œ±ŒΩ Œ≠Œ≥Œ∫œÖœÅŒ± Œ≥ŒµœâŒ≥œÅŒ±œÜŒπŒ∫Œ¨ œÉœÑŒøŒπœáŒµŒØŒ± œÉœÑŒ± Œ±œÅœáŒµŒØŒ± KML');
                }

            } catch (error) {
                console.error('‚ùå Error loading KML:', error);
                this.showError(`Œ£œÜŒ¨ŒªŒºŒ± œÜœåœÅœÑœâœÉŒ∑œÇ KML: ${error.message}`);
            } finally {
                this.showLoading(false);
            }
        }

        parseKML(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        const kmlString = e.target.result;
                        const parser = new DOMParser();
                        const kmlDoc = parser.parseFromString(kmlString, 'text/xml');
                        
                        // Check for parsing errors
                        const parseError = kmlDoc.querySelector('parsererror');
                        if (parseError) {
                            throw new Error('ŒúŒ∑ Œ≠Œ≥Œ∫œÖœÅŒø KML Œ±œÅœáŒµŒØŒø');
                        }

                        // Use toGeoJSON library if available
                        let geoJson;
                        if (typeof toGeoJSON !== 'undefined' && toGeoJSON.kml) {
                            geoJson = toGeoJSON.kml(kmlDoc);
                        } else {
                            // Manual parsing fallback
                            geoJson = this.manualKMLParse(kmlDoc);
                        }

                        if (!geoJson || !geoJson.features || geoJson.features.length === 0) {
                            throw new Error('ŒîŒµŒΩ Œ≤œÅŒ≠Œ∏Œ∑Œ∫Œ±ŒΩ Œ≥ŒµœâŒ≥œÅŒ±œÜŒπŒ∫Œ¨ œÉœÑŒøŒπœáŒµŒØŒ± œÉœÑŒø Œ±œÅœáŒµŒØŒø');
                        }

                        console.log(`üìÑ Parsed ${geoJson.features.length} features from ${file.name}`);
                        resolve(geoJson.features);

                    } catch (error) {
                        reject(new Error(`Œ£œÜŒ¨ŒªŒºŒ± Œ±ŒΩŒ¨ŒªœÖœÉŒ∑œÇ Œ±œÅœáŒµŒØŒøœÖ ${file.name}: ${error.message}`));
                    }
                };
                
                reader.onerror = () => reject(new Error('Œ£œÜŒ¨ŒªŒºŒ± Œ±ŒΩŒ¨Œ≥ŒΩœâœÉŒ∑œÇ Œ±œÅœáŒµŒØŒøœÖ'));
                reader.readAsText(file);
            });
        }

        manualKMLParse(kmlDoc) {
            const features = [];
            const placemarks = kmlDoc.querySelectorAll('Placemark');
            
            placemarks.forEach((placemark, index) => {
                const name = placemark.querySelector('name')?.textContent || `Feature ${index + 1}`;
                const description = placemark.querySelector('description')?.textContent || '';
                
                // Parse coordinates
                const coordsElements = placemark.querySelectorAll('coordinates');
                
                coordsElements.forEach(coordsEl => {
                    const coordsText = coordsEl.textContent.trim();
                    const coordinates = this.parseCoordinatesString(coordsText);
                    
                    if (coordinates.length > 0) {
                        let geometry;
                        
                        if (coordinates.length === 1) {
                            // Point
                            geometry = {
                                type: 'Point',
                                coordinates: coordinates[0]
                            };
                        } else if (coordinates.length >= 2) {
                            // Line or Polygon
                            const isPolygon = placemark.querySelector('Polygon') !== null;
                            geometry = {
                                type: isPolygon ? 'Polygon' : 'LineString',
                                coordinates: isPolygon ? [coordinates] : coordinates
                            };
                        }
                        
                        if (geometry) {
                            features.push({
                                type: 'Feature',
                                properties: { name, description },
                                geometry: geometry
                            });
                        }
                    }
                });
            });
            
            return { type: 'FeatureCollection', features: features };
        }

        parseCoordinatesString(coordsText) {
            const coordinates = [];
            const pairs = coordsText.split(/\s+/);
            
            pairs.forEach(pair => {
                const parts = pair.split(',');
                if (parts.length >= 2) {
                    const lng = parseFloat(parts[0]);
                    const lat = parseFloat(parts[1]);
                    const alt = parts[2] ? parseFloat(parts[2]) : 0;
                    
                    if (!isNaN(lng) && !isNaN(lat)) {
                        coordinates.push([lng, lat, alt]);
                    }
                }
            });
            
            return coordinates;
        }

        createARObject(feature) {
            if (!feature.geometry || !feature.geometry.coordinates) {
                console.warn('‚ùå Feature missing geometry:', feature);
                return false;
            }

            console.log(`üéØ Creating AR object for feature:`, feature);

            const entity = document.createElement('a-entity');
            entity.setAttribute('class', 'ar-object');
            
            // Get position for the object
            let position;
            try {
                switch (feature.geometry.type) {
                    case 'Point':
                        position = {
                            lat: feature.geometry.coordinates[1],
                            lng: feature.geometry.coordinates[0],
                            alt: feature.geometry.coordinates[2] || 0
                        };
                        break;
                    case 'LineString':
                        // Use midpoint
                        const coords = feature.geometry.coordinates;
                        const midIndex = Math.floor(coords.length / 2);
                        position = {
                            lat: coords[midIndex][1],
                            lng: coords[midIndex][0],
                            alt: coords[midIndex][2] || 0
                        };
                        break;
                    case 'Polygon':
                        // Calculate centroid for polygon positioning
                        const ring = feature.geometry.coordinates[0];
                        let latSum = 0, lngSum = 0, altSum = 0;
                        const validCoords = ring.slice(0, -1); // Remove duplicate last coordinate
                        validCoords.forEach(coord => {
                            lngSum += coord[0];
                            latSum += coord[1];
                            altSum += coord[2] || 0;
                        });
                        position = {
                            lat: latSum / validCoords.length,
                            lng: lngSum / validCoords.length,
                            alt: 0 // Force ground level for polygons
                        };
                        break;
                    default:
                        console.warn('‚ùå Unsupported geometry type:', feature.geometry.type);
                        return false;
                }
            } catch (error) {
                console.error('‚ùå Error calculating position for feature:', error);
                return false;
            }

            if (!position || isNaN(position.lat) || isNaN(position.lng)) {
                console.error('‚ùå Invalid position calculated:', position);
                return false;
            }

            console.log(`üìç AR object position:`, position);

            // Validate coordinates are reasonable
            if (Math.abs(position.lat) > 90 || Math.abs(position.lng) > 180) {
                console.error('‚ùå Invalid coordinates out of range:', position);
                return false;
            }

            // Set GPS position with explicit values
            const gpsAttrs = `latitude: ${position.lat.toFixed(6)}; longitude: ${position.lng.toFixed(6)}; altitude: ${position.alt || 0}`;
            console.log(`üåç Setting GPS attributes: ${gpsAttrs}`);
            entity.setAttribute('gps-new-entity-place', gpsAttrs);

            // Create visual representation
            try {
                this.createVisualForFeature(entity, feature);
            } catch (error) {
                console.error('‚ùå Error creating visual for feature:', error);
                return false;
            }

            // Add to scene
            try {
                this.container.appendChild(entity);
                
                // Calculate distance from user if available
                let distance = 'Unknown';
                let distanceInfo = '';
                if (this.userPosition) {
                    const distanceM = this.calculateDistance(
                        this.userPosition.latitude, this.userPosition.longitude,
                        position.lat, position.lng
                    );
                    distance = `${distanceM}m`;
                    distanceInfo = `Distance: ${distanceM}m, User: ${this.userPosition.latitude.toFixed(6)}, ${this.userPosition.longitude.toFixed(6)}, Object: ${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`;
                    
                    // Log detailed distance info for debugging
                    console.log(`üìè ${distanceInfo}`);
                    
                    // If object is very far, warn user
                    if (distanceM > 10000) {
                        console.warn(`‚ö†Ô∏è AR object is very far away (${distanceM}m). It might not be visible.`);
                    }
                }
                
                console.log(`‚úÖ AR object created successfully for ${feature.properties.name || 'Unnamed'} at ${position.lat.toFixed(6)}, ${position.lng.toFixed(6)} (${distance} away)`);
                
                // Also log in debug panel if enabled
                if (this.debugMode) {
                    console.log(`üîç Debug: ${distanceInfo}`);
                }
                
                return true;
            } catch (error) {
                console.error('‚ùå Error adding AR object to scene:', error);
                return false;
            }
        }

        calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371e3; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI/180;
            const œÜ2 = lat2 * Math.PI/180;
            const ŒîœÜ = (lat2-lat1) * Math.PI/180;
            const ŒîŒª = (lng2-lng1) * Math.PI/180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                    Math.cos(œÜ1) * Math.cos(œÜ2) *
                    Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return Math.round(R * c);
        }

        createVisualForFeature(entity, feature) {
            const type = feature.geometry.type;
            const name = feature.properties.name || 'Unnamed';
            
            console.log(`üé® Creating visual for ${type}: ${name}`);
            
            // Create geometry based on type - make them ground-level and realistic
            switch (type) {
                case 'Point':
                    // Vertical marker post for points
                    entity.setAttribute('geometry', 'primitive: cylinder; radius: 1; height: 10');
                    entity.setAttribute('material', 'color: #ff4444; emissive: #ff2222; emissiveIntensity: 0.3');
                    entity.setAttribute('position', '0 5 0'); // Half height above ground
                    break;
                case 'LineString':
                    // Line marker posts
                    entity.setAttribute('geometry', 'primitive: cylinder; radius: 0.5; height: 6');
                    entity.setAttribute('material', 'color: #4444ff; emissive: #2222ff; emissiveIntensity: 0.3');
                    entity.setAttribute('position', '0 3 0');
                    break;
                case 'Polygon':
                    // Ground-level polygon outline - create wireframe boundary
                    this.createPolygonOutline(entity, feature);
                    return; // Skip the rest for polygons as we handle them specially
            }

            // Add text label - smaller and at reasonable height
            const text = document.createElement('a-text');
            text.setAttribute('value', name);
            text.setAttribute('position', '0 8 0'); // Just above the marker
            text.setAttribute('align', 'center');
            text.setAttribute('color', '#ffffff');
            text.setAttribute('scale', '15 15 15');
            text.setAttribute('material', 'color: #ffffff; shader: msdf');
            text.setAttribute('look-at', '[gps-new-camera]');
            
            entity.appendChild(text);
            
            console.log(`‚ú® Visual created for ${name}`);
        }

        createPolygonOutline(entity, feature) {
            const name = feature.properties.name || 'Unnamed';
            console.log(`üèóÔ∏è Creating polygon outline for: ${name}`);
            
            // Get the outer ring coordinates
            const coordinates = feature.geometry.coordinates[0];
            
            // Create corner markers at each vertex
            coordinates.forEach((coord, index) => {
                if (index === coordinates.length - 1) return; // Skip last point (same as first)
                
                const cornerMarker = document.createElement('a-entity');
                cornerMarker.setAttribute('geometry', 'primitive: cylinder; radius: 0.8; height: 4');
                cornerMarker.setAttribute('material', 'color: #00ff00; emissive: #00cc00; emissiveIntensity: 0.5');
                cornerMarker.setAttribute('position', '0 2 0');
                
                // Calculate relative position from centroid
                const centroid = this.calculatePolygonCentroid(coordinates);
                const relativePos = this.coordsToRelativePosition(coord, centroid);
                
                cornerMarker.setAttribute('position', `${relativePos.x} 2 ${relativePos.z}`);
                entity.appendChild(cornerMarker);
                
                // Add corner number label
                const cornerText = document.createElement('a-text');
                cornerText.setAttribute('value', `${index + 1}`);
                cornerText.setAttribute('position', `0 3 0`);
                cornerText.setAttribute('align', 'center');
                cornerText.setAttribute('color', '#ffffff');
                cornerText.setAttribute('scale', '8 8 8');
                cornerText.setAttribute('look-at', '[gps-new-camera]');
                cornerMarker.appendChild(cornerText);
            });
            
            // Create a ground plane outline
            const outline = document.createElement('a-entity');
            outline.setAttribute('geometry', 'primitive: plane; width: 1; height: 1');
            outline.setAttribute('material', 'color: #44ff44; opacity: 0.3; transparent: true; side: double');
            outline.setAttribute('rotation', '-90 0 0');
            outline.setAttribute('position', '0 0.1 0'); // Slightly above ground
            
            // Scale the plane to approximate polygon size
            const bounds = this.calculatePolygonBounds(coordinates);
            const width = Math.abs(bounds.maxX - bounds.minX) * 111000; // Convert degrees to meters approximately
            const height = Math.abs(bounds.maxY - bounds.minY) * 111000;
            outline.setAttribute('geometry', `primitive: plane; width: ${width}; height: ${height}`);
            
            entity.appendChild(outline);
            
            // Add property name label at center
            const centerText = document.createElement('a-text');
            centerText.setAttribute('value', name);
            centerText.setAttribute('position', '0 6 0');
            centerText.setAttribute('align', 'center');
            centerText.setAttribute('color', '#ffffff');
            centerText.setAttribute('scale', '20 20 20');
            centerText.setAttribute('material', 'color: #ffffff; shader: msdf');
            centerText.setAttribute('look-at', '[gps-new-camera]');
            entity.appendChild(centerText);
            
            console.log(`‚úÖ Polygon outline created with ${coordinates.length - 1} corner markers`);
        }

        calculatePolygonCentroid(coordinates) {
            let latSum = 0, lngSum = 0;
            const validCoords = coordinates.slice(0, -1); // Remove duplicate last point
            
            validCoords.forEach(coord => {
                lngSum += coord[0];
                latSum += coord[1];
            });
            
            return {
                lat: latSum / validCoords.length,
                lng: lngSum / validCoords.length
            };
        }
        
        calculatePolygonBounds(coordinates) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            coordinates.forEach(coord => {
                minX = Math.min(minX, coord[0]);
                maxX = Math.max(maxX, coord[0]);
                minY = Math.min(minY, coord[1]);
                maxY = Math.max(maxY, coord[1]);
            });
            
            return { minX, maxX, minY, maxY };
        }
        
        coordsToRelativePosition(coord, centroid) {
            // Convert lat/lng difference to approximate meter offsets
            const latDiff = coord[1] - centroid.lat;
            const lngDiff = coord[0] - centroid.lng;
            
            // Rough conversion: 1 degree ‚âà 111,000 meters
            const x = lngDiff * 111000 * Math.cos(centroid.lat * Math.PI / 180);
            const z = -latDiff * 111000; // Negative because Z+ is south in AR.js
            
            return { x, z };
        }

        forceUpdateARObjects() {
            console.log('üîÑ Force updating AR objects...');
            
            // Ensure all AR objects are visible and properly positioned
            const children = Array.from(this.container.children);
            children.forEach((child, index) => {
                console.log(`üîÑ Updating AR object ${index + 1}/${children.length}`);
                
                // Force visibility
                child.setAttribute('visible', 'true');
                
                // Trigger a position update if GPS component exists
                if (child.components && child.components['gps-new-entity-place']) {
                    try {
                        child.components['gps-new-entity-place'].tick();
                    } catch (e) {
                        console.log('Could not force tick GPS component:', e.message);
                    }
                }
                
                // Log current transform
                const position = child.getAttribute('position');
                const gpsPos = child.getAttribute('gps-new-entity-place');
                console.log(`üìç AR Object ${index}: GPS=${JSON.stringify(gpsPos)}, Position=${JSON.stringify(position)}`);
            });
            
            console.log(`‚úÖ Force update complete for ${children.length} AR objects`);
        }

        updateDebugInfo() {
            if (!this.debugMode) return;
            
            // Add more detailed debugging information
            const debugPanel = document.getElementById('debug-panel');
            
            // Remove old extra debug info
            const extraDebugElements = debugPanel.querySelectorAll('.extra-debug');
            extraDebugElements.forEach(el => el.remove());
            
            // Add current AR objects info
            if (this.container.children.length > 0) {
                Array.from(this.container.children).forEach((child, index) => {
                    const gpsAttr = child.getAttribute('gps-new-entity-place');
                    const position = child.getAttribute('position');
                    
                    const debugDiv = document.createElement('div');
                    debugDiv.className = 'extra-debug';
                    debugDiv.textContent = `AR${index}: GPS(${gpsAttr ? gpsAttr.latitude + ',' + gpsAttr.longitude : 'none'}) POS(${position ? position.x + ',' + position.y + ',' + position.z : 'none'})`;
                    debugPanel.appendChild(debugDiv);
                });
            }
        }

        clearAll() {
            // Remove all AR objects
            while (this.container.firstChild) {
                this.container.removeChild(this.container.firstChild);
            }
            
            this.features = [];
            this.updateStatus('features', false, 'Œ£œÑŒøŒπœáŒµŒØŒ±: 0');
            
            if (this.debugMode) {
                document.getElementById('debug-features').textContent = '0';
                document.getElementById('debug-objects').textContent = '0';
                this.updateDebugInfo();
            }
            
            this.showInfo('üóëÔ∏è ŒåŒªŒ± œÑŒ± AR œÉœÑŒøŒπœáŒµŒØŒ± Œ∫Œ±Œ∏Œ±œÅŒØœÉœÑŒ∑Œ∫Œ±ŒΩ');
            
            // Clear file input
            document.getElementById('kml-input').value = '';
        }

        updateStatus(type, active, text) {
            const dot = document.getElementById(`${type}-dot`);
            const textEl = document.getElementById(`${type}-text`);
            
            if (dot && textEl) {
                if (active) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
                textEl.textContent = text;
            }
        }

        showInfo(message) {
            const info = document.getElementById('info');
            info.innerHTML = message;
            info.classList.add('show');
            
            setTimeout(() => {
                info.classList.remove('show');
            }, 10000); // Increased timeout for longer messages
        }

        showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        showError(message) {
            const dialog = document.getElementById('error-dialog');
            document.getElementById('error-text').textContent = message;
            dialog.style.display = 'block';
        }
    }

    // Global functions
    function hideError() {
        document.getElementById('error-dialog').style.display = 'none';
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
        // Check for HTTPS
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
            document.getElementById('error-text').textContent = 
                'Œó ŒµœÜŒ±œÅŒºŒøŒ≥ŒÆ Œ±œÄŒ±ŒπœÑŒµŒØ HTTPS Œ≥ŒπŒ± œÄœÅœåœÉŒ≤Œ±œÉŒ∑ œÉœÑŒ∑ŒΩ Œ∫Œ¨ŒºŒµœÅŒ± Œ∫Œ±Œπ GPS. Œ†Œ±œÅŒ±Œ∫Œ±Œªœé œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒÆœÉœÑŒµ https://olympos2025.github.io/DotsikoAR-WebAR/';
            document.getElementById('error-dialog').style.display = 'block';
            return;
        }

        // Initialize MapLens
        window.mapLensAR = new MapLensAR();
    });

    // Handle device orientation permission on user interaction
    let permissionRequested = false;
    async function requestPermissions() {
        if (permissionRequested) return;
        permissionRequested = true;
        
        console.log('üîê User interaction detected, requesting permissions...');
        
        try {
            // Request orientation permission
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                
                console.log('üì± Requesting iOS permissions...');
                await DeviceOrientationEvent.requestPermission();
            }
            
            // Also request motion permission if available
            if (typeof DeviceMotionEvent !== 'undefined' && 
                typeof DeviceMotionEvent.requestPermission === 'function') {
                
                await DeviceMotionEvent.requestPermission();
            }
            
            console.log('‚úÖ Permissions requested');
            
        } catch (error) {
            console.error('‚ùå Permission request failed:', error);
        }
    }

    // Add permission button for iOS
    function addPermissionButton() {
        const permissionBtn = document.createElement('button');
        permissionBtn.textContent = 'üîê ŒïŒΩŒµœÅŒ≥ŒøœÄŒøŒØŒ∑œÉŒ∑ ŒëŒπœÉŒ∏Œ∑œÑŒÆœÅœâŒΩ';
        permissionBtn.className = 'btn btn-success';
        permissionBtn.style.position = 'fixed';
        permissionBtn.style.top = '50%';
        permissionBtn.style.left = '50%';
        permissionBtn.style.transform = 'translate(-50%, -50%)';
        permissionBtn.style.zIndex = '10001';
        permissionBtn.style.padding = '15px 25px';
        permissionBtn.style.fontSize = '16px';
        
        permissionBtn.onclick = async () => {
            await requestPermissions();
            permissionBtn.remove();
            
            // Restart the app
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        };
        
        document.body.appendChild(permissionBtn);
    }

    // Check if iOS and add permission button
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    if (isIOS) {
        setTimeout(addPermissionButton, 2000);
    }

    document.addEventListener('click', requestPermissions, { once: true });
    document.addEventListener('touchstart', requestPermissions, { once: true });
</script>
```

</body>
</html>