<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MapLens</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #2D9CDB;
      --secondary: #56CCF2;
      --accent: #6FCF97;
      --background: #F7FAFC;
      --dark: #222B45;
      --grid: #E0E7EF;
      --glass: rgba(255,255,255,0.78);
      --radius: 22px;
      --shadow: 0 8px 32px 0 rgba(44, 62, 80, 0.08);
      --sidebar-width: 340px;
      --frame-thickness: 24px;
      --tick-spacing: 40px;
      --tick-length: 6px;
    }
    body {
      margin: 0;
      font-family: 'Inter', sans-serif;
      background: var(--background);
      color: var(--dark);
      overflow: hidden;
    }
    /* Glass frame with grid */
    .frame-container {
      position: fixed;
      inset: 0;
      z-index: 9998;
      pointer-events: none;
      background:
        linear-gradient(to right, var(--grid) 1px, transparent 1px) repeat-x,
        linear-gradient(to bottom, var(--grid) 1px, transparent 1px) repeat-y;
      background-size: var(--tick-spacing) var(--tick-spacing);
      border: var(--frame-thickness) solid rgba(45,156,219,0.18);
      box-sizing: border-box;
      border-radius: var(--radius);
    }
    /* Tick marks */
    .tick-marks { position: absolute; inset: 0; pointer-events: none; }
    .tick-mark {
      position: absolute; background: var(--primary); opacity: 0.4;
      z-index: 9999;
      border-radius: 2px;
    }
    .tick-mark.h { width: 2px; height: var(--tick-length);}
    .tick-mark.v { height: 2px; width: var(--tick-length);}
    /* Floating menu button */
    #menu-toggle {
      position: fixed;
      top: calc(var(--frame-thickness) + 18px);
      left: calc(var(--frame-thickness) + 18px);
      z-index: 10000;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: white;
      border: none;
      width: 48px; height: 48px;
      border-radius: 50%;
      font-size: 24px;
      box-shadow: var(--shadow);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s;
    }
    #menu-toggle:hover { background: var(--secondary); }
    /* Language selector */
    .language-selector {
      position: fixed;
      top: calc(var(--frame-thickness) + 18px);
      right: calc(var(--frame-thickness) + 18px);
      z-index: 10000;
      display: flex; gap: 8px;
    }
    .language-selector button {
      background: var(--glass);
      color: var(--dark);
      border: 2px solid var(--primary);
      border-radius: 14px;
      font-weight: 600;
      width: 48px; height: 38px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(44, 62, 80, 0.06);
      transition: background 0.2s, color 0.2s;
    }
    .language-selector button.active {
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      color: white;
      border: 2px solid var(--secondary);
    }
    /* Sidebar */
    .sidebar {
      position: fixed;
      top: var(--frame-thickness);
      left: var(--frame-thickness);
      height: calc(100vh - var(--frame-thickness)*2);
      width: var(--sidebar-width);
      background: var(--glass);
      backdrop-filter: blur(16px);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      z-index: 9999;
      transform: translateX(-120%);
      transition: transform 0.5s cubic-bezier(.77,0,.18,1);
      display: flex;
      flex-direction: column;
      gap: 22px;
      padding: 34px 28px 24px 28px;
    }
    .sidebar.open { transform: translateX(0); }
    /* Logo */
    .app-logo { text-align: center; margin-bottom: 16px;}
    .logo-circle {
      width: 54px; height: 54px; margin: 0 auto 12px auto;
      background: var(--primary);
      border-radius: 50%;
      box-shadow: 0 4px 16px 0 var(--secondary), 0 2px 8px 0 var(--accent);
      display: flex; align-items: center; justify-content: center;
      font-size: 2em; color: white; font-weight: 700;
      letter-spacing: -1px;
    }
    .logo-text {
      font-size: 1.6em;
      font-weight: 700;
      letter-spacing: -1px;
      color: var(--primary);
      font-family: 'Inter', sans-serif;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: lowercase;
    }
    .app-tagline {
      font-size: 1em;
      color: var(--dark);
      opacity: 0.7;
      margin-bottom: 10px;
      font-weight: 400;
    }
    /* Status panel */
    .status-panel {
      background: var(--glass);
      border-radius: var(--radius);
      box-shadow: 0 2px 8px rgba(44, 62, 80, 0.06);
      padding: 16px 18px;
      margin-bottom: 8px;
    }
    .status-list { list-style: none; padding: 0; margin: 0;}
    .status-list li {
      display: flex; align-items: center; gap: 10px;
      font-size: 1em; margin-bottom: 5px;
    }
    .status-list li:last-child { margin-bottom: 0;}
    .status-icon {
      font-size: 1.1em;
      color: var(--primary);
      display: flex; align-items: center; justify-content: center;
      width: 1.5em; height: 1.5em;
    }
    .status-value { font-weight: 600;}
    .accuracy-badge {
      padding: 2px 10px;
      border-radius: 12px;
      font-size: 0.95em;
      font-weight: 600;
      margin-left: 4px;
      background: var(--secondary);
      color: white;
    }
    /* Form panel */
    .form-panel {
      background: var(--glass);
      border-radius: var(--radius);
      box-shadow: 0 2px 8px rgba(44, 62, 80, 0.06);
      padding: 18px 18px 12px 18px;
      margin-bottom: 8px;
    }
    .form-panel input[type="text"] {
      width: 100%;
      padding: 10px 14px;
      border: 1.5px solid var(--primary);
      border-radius: 14px;
      font-size: 1em;
      margin-bottom: 10px;
      background: rgba(255,255,255,0.8);
      color: var(--dark);
      transition: border 0.2s;
    }
    .form-panel input[type="text"]:focus {
      border-color: var(--secondary);
      outline: none;
    }
    .btn {
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      color: white;
      border: none;
      border-radius: 14px;
      font-size: 1em;
      font-weight: 600;
      padding: 12px 0;
      margin: 6px 0;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(44, 62, 80, 0.08);
      transition: background 0.2s, box-shadow 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .btn:active { background: var(--secondary);}
    .btn-alt {
      background: white;
      color: var(--primary);
      border: 1.5px solid var(--primary);
      box-shadow: none;
    }
    .divider {
      text-align: center;
      color: var(--dark);
      opacity: 0.5;
      margin: 8px 0;
      font-size: 0.97em;
    }
    .error-message {
      background: rgba(255, 61, 111, 0.15);
      color: #FF3D6F;
      border-radius: 12px;
      padding: 12px 16px;
      font-size: 1em;
      margin-top: 12px;
      display: none;
    }
    .copyright {
      position: fixed;
      bottom: calc(var(--frame-thickness) + 10px);
      right: calc(var(--frame-thickness) + 10px);
      font-size: 0.9em;
      color: var(--dark);
      opacity: 0.6;
      background: var(--glass);
      border-radius: 16px;
      padding: 7px 14px;
      z-index: 10000;
      box-shadow: 0 2px 8px rgba(44, 62, 80, 0.06);
    }
    .copyright a { color: var(--primary); text-decoration: none;}
    .copyright a:hover { color: var(--accent);}
    @media (max-width: 600px) {
      :root { --sidebar-width: 95vw; }
      .sidebar { padding: 18px 7vw 12px 7vw; }
    }
  </style>
</head>
<body>
  <div class="frame-container"></div>
  <div class="tick-marks" id="tick-marks"></div>
  <button id="menu-toggle">☰</button>
  <div class="language-selector">
    <button id="lang-el" class="active">EL</button>
    <button id="lang-en">EN</button>
  </div>
  <div class="copyright">
    © 2025 Thomas G. Lagkas | <a href="mailto:Thomas.lagkas@outlook.com">Thomas.lagkas@outlook.com</a>
  </div>
  <div class="sidebar" id="sidebar">
    <div class="app-logo">
      <div class="logo-circle">M</div>
      <div class="logo-text">maplens</div>
      <div class="app-tagline" data-el="Δες τον κόσμο αλλιώς" data-en="See the world differently">Δες τον κόσμο αλλιώς</div>
    </div>
    <div class="status-panel">
      <ul class="status-list">
        <li><span class="status-icon">📡</span><span id="status">⌛ Αναμονή GPS...</span></li>
        <li><span class="status-icon">📏</span><span id="accuracy">Ακρίβεια GPS: Αναμονή...</span></li>
        <li><span class="status-icon">🕑</span><span id="datetime"></span></li>
      </ul>
    </div>
    <div class="form-panel">
      <input type="file" id="file-input" accept=".kml">
      <button id="upload-btn" class="btn" data-el="Φόρτωση KML" data-en="Load KML">Φόρτωση KML</button>
      <div class="divider" data-el="ή" data-en="or">ή</div>
      <input type="text" id="url-input" placeholder="URL του KML αρχείου" data-el-placeholder="URL του KML αρχείου" data-en-placeholder="KML file URL">
      <button id="load-url-btn" class="btn" data-el="Φόρτωση από URL" data-en="Load from URL">Φόρτωση από URL</button>
    </div>
    <div class="form-panel">
      <button id="toggle-btn" class="btn" data-el="Εμφάνιση/Απόκρυψη AR" data-en="Show/Hide AR">Εμφάνιση/Απόκρυψη AR</button>
      <button id="reset-btn" class="btn btn-alt" data-el="Επαναφορά" data-en="Reset">Επαναφορά</button>
    </div>
    <div id="error-message" class="error-message"></div>
  </div>
  <a-scene 
    vr-mode-ui="enabled: false"
    arjs="sourceType: webcam; debugUIEnabled: false; sourceWidth: 1280; sourceHeight: 960;"
    renderer="logarithmicDepthBuffer: true; precision: medium;"
    embedded>
    <a-camera gps-camera rotation-reader></a-camera>
    <a-entity id="kml-container"></a-entity>
  </a-scene>
  <script>
    // Tick marks
    function createTickMarks() {
      const tickMarks = document.getElementById('tick-marks');
      tickMarks.innerHTML = '';
      const w = window.innerWidth, h = window.innerHeight;
      const frame = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--frame-thickness'));
      const spacing = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tick-spacing'));
      const len = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tick-length'));
      // Top/bottom
      for (let x = frame; x < w - frame; x += spacing) {
        let t = document.createElement('div');
        t.className = 'tick-mark h'; t.style.top = frame + 'px'; t.style.left = x + 'px';
        tickMarks.appendChild(t);
        let b = document.createElement('div');
        b.className = 'tick-mark h'; b.style.bottom = frame + 'px'; b.style.left = x + 'px';
        tickMarks.appendChild(b);
      }
      // Left/right
      for (let y = frame; y < h - frame; y += spacing) {
        let l = document.createElement('div');
        l.className = 'tick-mark v'; l.style.left = frame + 'px'; l.style.top = y + 'px';
        tickMarks.appendChild(l);
        let r = document.createElement('div');
        r.className = 'tick-mark v'; r.style.right = frame + 'px'; r.style.top = y + 'px';
        tickMarks.appendChild(r);
      }
    }
    window.addEventListener('resize', createTickMarks);
    window.addEventListener('DOMContentLoaded', createTickMarks);

    // Sidebar menu
    const menuToggle = document.getElementById('menu-toggle');
    const sidebar = document.getElementById('sidebar');
    menuToggle.addEventListener('click', () => {
      sidebar.classList.toggle('open');
    });

    // Language switching
    let currentLanguage = 'el';
    const langEl = document.getElementById('lang-el');
    const langEn = document.getElementById('lang-en');
    langEl.addEventListener('click', () => setLanguage('el'));
    langEn.addEventListener('click', () => setLanguage('en'));
    function setLanguage(lang) {
      currentLanguage = lang;
      langEl.classList.toggle('active', lang === 'el');
      langEn.classList.toggle('active', lang === 'en');
      document.querySelectorAll('[data-el][data-en]').forEach(el => {
        el.textContent = el.getAttribute(`data-${lang}`);
      });
      document.querySelectorAll('[data-el-placeholder][data-en-placeholder]').forEach(el => {
        el.setAttribute('placeholder', el.getAttribute(`data-${lang}-placeholder`));
      });
    }

    // Date/time
    function updateDateTime() {
      document.getElementById('datetime').textContent =
        new Date().toLocaleString(currentLanguage === 'el' ? 'el-GR' : 'en-US');
      setTimeout(updateDateTime, 1000);
    }
    updateDateTime();

    // Translations
    const translations = {
      el: {
        waiting: "⌛ Αναμονή GPS...",
        active: "✅ GPS ενεργό",
        loading: "⏳ Φόρτωση KML...",
        loaded: "✅ KML φορτώθηκε!",
        error: "❌ Σφάλμα!",
        reset: "AR επαναφέρθηκε",
        accuracy: "Ακρίβεια GPS: ",
        notAvailable: "Ακρίβεια GPS: Μη διαθέσιμη",
        urlRequired: "Παρακαλώ εισάγετε ένα URL!",
        noPolygons: "Δεν βρέθηκαν πολύγωνα/γραμμές/σημεία στο KML!",
        invalidXml: "Μη έγκυρο XML!",
        readError: "Σφάλμα ανάγνωσης αρχείου!",
        parseError: "Σφάλμα ανάλυσης KML: ",
        downloadError: "Σφάλμα λήψης KML: ",
        meters: "m",
        hideAR: "Απόκρυψη AR",
        showAR: "Εμφάνιση AR"
      },
      en: {
        waiting: "⌛ Waiting for GPS...",
        active: "✅ GPS active",
        loading: "⏳ Loading KML...",
        loaded: "✅ KML loaded!",
        error: "❌ Error!",
        reset: "AR reset",
        accuracy: "GPS accuracy: ",
        notAvailable: "GPS accuracy: Not available",
        urlRequired: "Please enter a URL!",
        noPolygons: "No polygons/lines/points found in the KML!",
        invalidXml: "Invalid XML!",
        readError: "Error reading file!",
        parseError: "Error parsing KML: ",
        downloadError: "Error downloading KML: ",
        meters: "m",
        hideAR: "Hide AR",
        showAR: "Show AR"
      }
    };

    // Status update
    let arVisible = true, currentAccuracy = null, userPosition = null;
    const statusEl = document.getElementById('status');
    const accuracyEl = document.getElementById('accuracy');
    const toggleBtn = document.getElementById('toggle-btn');
    const resetBtn = document.getElementById('reset-btn');
    const errorMessageEl = document.getElementById('error-message');
    const kmlContainer = document.getElementById('kml-container');
    toggleBtn.addEventListener('click', () => {
      arVisible = !arVisible;
      kmlContainer.setAttribute('visible', arVisible);
      toggleBtn.textContent = arVisible ? translations[currentLanguage].hideAR : translations[currentLanguage].showAR;
    });
    resetBtn.addEventListener('click', () => {
      kmlContainer.innerHTML = '';
      statusEl.textContent = translations[currentLanguage].reset;
    });

    // GPS status
    document.addEventListener('DOMContentLoaded', () => {
      const camera = document.querySelector('a-camera');
      camera.addEventListener('gps-camera-update-position', e => {
        userPosition = e.detail.position;
        statusEl.textContent = translations[currentLanguage].active;
        let acc = null;
        if (e.detail.position && e.detail.position.accuracy !== undefined) {
          acc = e.detail.position.accuracy;
        } else if (e.detail.accuracy !== undefined) {
          acc = e.detail.accuracy;
        }
        if (acc !== null) {
          currentAccuracy = acc;
          accuracyEl.textContent = `${translations[currentLanguage].accuracy}±${currentAccuracy.toFixed(2)}${translations[currentLanguage].meters}`;
          accuracyEl.className = 'accuracy-badge';
          if (currentAccuracy <= 10) accuracyEl.style.background = "#6FCF97";
          else if (currentAccuracy <= 20) accuracyEl.style.background = "#56CCF2";
          else accuracyEl.style.background = "#F2994A";
        } else {
          accuracyEl.textContent = translations[currentLanguage].notAvailable;
          accuracyEl.className = '';
        }
      });
    });

    // KML loading
    const fileInput = document.getElementById('file-input');
    const uploadBtn = document.getElementById('upload-btn');
    const urlInput = document.getElementById('url-input');
    const loadUrlBtn = document.getElementById('load-url-btn');
    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileUpload);
    loadUrlBtn.addEventListener('click', handleUrlLoad);

    function handleFileUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      statusEl.textContent = translations[currentLanguage].loading;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const polygons = parseKML(e.target.result);
          if (!polygons || polygons.length === 0) {
            showError(translations[currentLanguage].noPolygons);
          } else {
            renderPolygons(polygons);
            statusEl.textContent = translations[currentLanguage].loaded;
          }
        } catch (err) {
          showError(translations[currentLanguage].parseError + err.message);
        }
      };
      reader.onerror = function() {
        showError(translations[currentLanguage].readError);
      };
      reader.readAsText(file);
    }

    function handleUrlLoad() {
      const url = urlInput.value.trim();
      if (!url) {
        showError(translations[currentLanguage].urlRequired);
        return;
      }
      statusEl.textContent = translations[currentLanguage].loading;
      fetch(url)
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
          return response.text();
        })
        .then(kmlText => {
          try {
            const polygons = parseKML(kmlText);
            if (!polygons || polygons.length === 0) {
              showError(translations[currentLanguage].noPolygons);
            } else {
              renderPolygons(polygons);
              statusEl.textContent = translations[currentLanguage].loaded;
            }
          } catch (err) {
            showError(translations[currentLanguage].parseError + err.message);
          }
        })
        .catch(error => {
          showError(translations[currentLanguage].downloadError + error.message);
        });
    }

    function showError(message) {
      errorMessageEl.textContent = message;
      errorMessageEl.style.display = 'block';
      setTimeout(() => { errorMessageEl.style.display = 'none'; }, 5000);
      statusEl.textContent = translations[currentLanguage].error;
    }

    function parseKML(kmlText) {
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(kmlText, "text/xml");
      const parserError = kmlDoc.getElementsByTagName('parsererror');
      if (parserError.length > 0) throw new Error(translations[currentLanguage].invalidXml);
      const polygons = [];
      const placemarks = kmlDoc.getElementsByTagName('Placemark');
      for (let i = 0; i < placemarks.length; i++) {
        const placemark = placemarks[i];
        const nameEl = placemark.getElementsByTagName('name')[0];
        const name = nameEl ? nameEl.textContent : "Στοιχείο " + (i + 1);
        // Πολύγωνα
        const polygonElements = placemark.getElementsByTagName('Polygon');
        for (let j = 0; j < polygonElements.length; j++) {
          const polygon = polygonElements[j];
          const coordsElements = polygon.getElementsByTagName('coordinates');
          if (coordsElements.length > 0) {
            const coordsText = coordsElements[0].textContent.trim();
            const coords = parseCoordinateString(coordsText);
            if (coords.length > 2) {
              polygons.push({type: 'polygon', name, points: coords});
            }
          }
        }
        // Γραμμές
        const lineElements = placemark.getElementsByTagName('LineString');
        for (let j = 0; j < lineElements.length; j++) {
          const line = lineElements[j];
          const coordsElements = line.getElementsByTagName('coordinates');
          if (coordsElements.length > 0) {
            const coordsText = coordsElements[0].textContent.trim();
            const coords = parseCoordinateString(coordsText);
            if (coords.length > 1) {
              polygons.push({type: 'line', name, points: coords});
            }
          }
        }
        // Σημεία
        const pointElements = placemark.getElementsByTagName('Point');
        for (let j = 0; j < pointElements.length; j++) {
          const point = pointElements[j];
          const coordsElements = point.getElementsByTagName('coordinates');
          if (coordsElements.length > 0) {
            const coordsText = coordsElements[0].textContent.trim();
            const coords = parseCoordinateString(coordsText);
            if (coords.length > 0) {
              polygons.push({type: 'point', name, points: coords});
            }
          }
        }
      }
      return polygons;
    }
    function parseCoordinateString(coordsText) {
      const coordinates = [];
      const coordPairs = coordsText.split(/\s+/);
      for (let i = 0; i < coordPairs.length; i++) {
        const pair = coordPairs[i].trim();
        if (!pair) continue;
        const coords = pair.split(',');
        if (coords.length >= 2) {
          const lon = parseFloat(coords[0]);
          const lat = parseFloat(coords[1]);
          if (!isNaN(lon) && !isNaN(lat)) {
            coordinates.push({ lat, lon });
          }
        }
      }
      return coordinates;
    }
    function renderPolygons(polygons) {
      kmlContainer.innerHTML = '';
      polygons.forEach((polygon, index) => {
        if (polygon.type === 'polygon') {
          renderPolygon(polygon, index);
        } else if (polygon.type === 'line') {
          renderLine(polygon, index);
        } else if (polygon.type === 'point') {
          renderPoint(polygon, index);
        }
      });
    }
    function renderPolygon(polygon, index) {
      const points = polygon.points;
      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        const line = document.createElement('a-entity');
        line.setAttribute('gps-entity-place', `latitude: ${p1.lat}; longitude: ${p1.lon}`);
        line.setAttribute('line', {
          start: '0 0 0',
          end: `${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).x} 0 ${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).z}`,
          color: '#2D9CDB',
          opacity: 0.85,
          width: 6
        });
        kmlContainer.appendChild(line);
      }
      let avgLat = 0, avgLon = 0;
      points.forEach(p => { avgLat += p.lat; avgLon += p.lon; });
      avgLat /= points.length;
      avgLon /= points.length;
      let maxDistance = 0;
      points.forEach(p => {
        const distance = geoDistance(avgLat, avgLon, p.lat, p.lon);
        if (distance > maxDistance) maxDistance = distance;
      });
      const fill = document.createElement('a-entity');
      fill.setAttribute('gps-entity-place', `latitude: ${avgLat}; longitude: ${avgLon}`);
      fill.setAttribute('geometry', {
        primitive: 'plane',
        width: maxDistance * 2,
        height: maxDistance * 2
      });
      fill.setAttribute('material', {
        color: '#56CCF2',
        opacity: 0.25,
        transparent: true,
        side: 'double'
      });
      fill.setAttribute('rotation', '-90 0 0');
      kmlContainer.appendChild(fill);
      const text = document.createElement('a-text');
      text.setAttribute('gps-entity-place', `latitude: ${avgLat}; longitude: ${avgLon}`);
      text.setAttribute('value', polygon.name);
      text.setAttribute('scale', '7 7 7');
      text.setAttribute('look-at', '[gps-camera]');
      text.setAttribute('align', 'center');
      text.setAttribute('color', '#2D9CDB');
      text.setAttribute('position', '0 12 0');
      kmlContainer.appendChild(text);
    }
    function renderLine(line, index) {
      const points = line.points;
      for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i + 1];
        const lineEntity = document.createElement('a-entity');
        lineEntity.setAttribute('gps-entity-place', `latitude: ${p1.lat}; longitude: ${p1.lon}`);
        lineEntity.setAttribute('line', {
          start: '0 0 0',
          end: `${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).x} 0 ${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).z}`,
          color: '#6FCF97',
          opacity: 0.9,
          width: 4
        });
        kmlContainer.appendChild(lineEntity);
      }
      if (points.length > 0) {
        const midPoint = points[Math.floor(points.length / 2)];
        const text = document.createElement('a-text');
        text.setAttribute('gps-entity-place', `latitude: ${midPoint.lat}; longitude: ${midPoint.lon}`);
        text.setAttribute('value', line.name);
        text.setAttribute('scale', '6 6 6');
        text.setAttribute('look-at', '[gps-camera]');
        text.setAttribute('align', 'center');
        text.setAttribute('color', '#2D9CDB');
        text.setAttribute('position', '0 10 0');
        kmlContainer.appendChild(text);
      }
    }
    function renderPoint(point, index) {
      if (point.points.length > 0) {
        const p = point.points[0];
        const sphere = document.createElement('a-sphere');
        sphere.setAttribute('gps-entity-place', `latitude: ${p.lat}; longitude: ${p.lon}`);
        sphere.setAttribute('color', '#6FCF97');
        sphere.setAttribute('radius', '2.5');
        sphere.setAttribute('position', '0 0 0');
        kmlContainer.appendChild(sphere);
        const text = document.createElement('a-text');
        text.setAttribute('gps-entity-place', `latitude: ${p.lat}; longitude: ${p.lon}`);
        text.setAttribute('value', point.name);
        text.setAttribute('scale', '5 5 5');
        text.setAttribute('look-at', '[gps-camera]');
        text.setAttribute('align', 'center');
        text.setAttribute('color', '#2D9CDB');
        text.setAttribute('position', '0 8 0');
        kmlContainer.appendChild(text);
      }
    }
    function geoToMeters(lat1, lon1, lat2, lon2) {
      const R = 6378137;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      const distance = R * c;
      const bearing = Math.atan2(
        Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180),
        Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
        Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon)
      );
      const x = distance * Math.sin(bearing);
      const z = distance * Math.cos(bearing);
      return { x, y: 0, z };
    }
    function geoDistance(lat1, lon1, lat2, lon2) {
      const R = 6378137;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
  </script>
</body>
</html>
