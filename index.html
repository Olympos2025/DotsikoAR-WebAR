<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>DotsikoAR WebAR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- A-Frame & AR.js -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <style>
        #ui-container {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .panel {
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        #info-panel {
            max-width: 250px;
        }
        #status {
            color: #333;
            font-weight: bold;
        }
        #accuracy {
            color: green;
        }
        #datetime {
            font-size: 0.9em;
            color: #666;
        }
        #app-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #45a049;
        }
        #file-input {
            display: none;
        }
        #error-message {
            color: red;
            display: none;
        }
    </style>
</head>
<body style="margin: 0; overflow: hidden;">
    <!-- UI Elements -->
    <div id="ui-container">
        <div id="info-panel" class="panel">
            <div id="app-name">DotsikoAR</div>
            <div id="status">‚åõ ŒëŒΩŒ±ŒºŒøŒΩŒÆ GPS...</div>
            <div id="accuracy"></div>
            <div id="datetime"></div>
        </div>
        
        <div class="panel">
            <input type="file" id="file-input" accept=".kml">
            <button id="upload-btn" class="btn">Œ¶œåœÅœÑœâœÉŒ∑ KML</button>
            <div>ŒÆ</div>
            <input type="text" id="url-input" placeholder="URL œÑŒøœÖ KML Œ±œÅœáŒµŒØŒøœÖ">
            <button id="load-url-btn" class="btn">Œ¶œåœÅœÑœâœÉŒ∑ Œ±œÄœå URL</button>
        </div>
        
        <div class="panel">
            <button id="toggle-btn" class="btn">ŒïŒºœÜŒ¨ŒΩŒπœÉŒ∑/ŒëœÄœåŒ∫œÅœÖœàŒ∑ AR</button>
            <button id="reset-btn" class="btn">ŒïœÄŒ±ŒΩŒ±œÜŒøœÅŒ¨</button>
        </div>
        
        <div id="error-message" class="panel"></div>
    </div>

    <!-- A-Frame Scene -->
    <a-scene 
        vr-mode-ui="enabled: false"
        arjs="sourceType: webcam; debugUIEnabled: false; sourceWidth: 1280; sourceHeight: 960;"
        renderer="logarithmicDepthBuffer: true; precision: medium;"
        embedded>
        
        <a-camera gps-camera rotation-reader></a-camera>
        <a-entity id="kml-container"></a-entity>
    </a-scene>

    <script>
        // Global variables
        let arVisible = true;
        let currentAccuracy = 0;
        let userPosition = null;
        
        // DOM Elements
        const fileInput = document.getElementById('file-input');
        const uploadBtn = document.getElementById('upload-btn');
        const urlInput = document.getElementById('url-input');
        const loadUrlBtn = document.getElementById('load-url-btn');
        const toggleBtn = document.getElementById('toggle-btn');
        const resetBtn = document.getElementById('reset-btn');
        const statusEl = document.getElementById('status');
        const accuracyEl = document.getElementById('accuracy');
        const datetimeEl = document.getElementById('datetime');
        const errorMessageEl = document.getElementById('error-message');
        const kmlContainer = document.getElementById('kml-container');
        
        // Initialize date & time
        function updateDateTime() {
            const now = new Date();
            datetimeEl.textContent = now.toLocaleString('el-GR');
        }
        setInterval(updateDateTime, 1000);
        updateDateTime();
        
        // Event listeners
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileUpload);
        loadUrlBtn.addEventListener('click', handleUrlLoad);
        toggleBtn.addEventListener('click', toggleARVisibility);
        resetBtn.addEventListener('click', resetAR);
        
        // Handle KML file upload
        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            statusEl.textContent = "‚è≥ Œ¶œåœÅœÑœâœÉŒ∑ KML...";
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const polygons = parseKML(e.target.result);
                    if (!polygons || polygons.length === 0) {
                        showError("ŒîŒµŒΩ Œ≤œÅŒ≠Œ∏Œ∑Œ∫Œ±ŒΩ œÄŒøŒªœçŒ≥œâŒΩŒ± œÉœÑŒø KML!");
                    } else {
                        renderPolygons(polygons);
                        statusEl.textContent = "‚úÖ KML œÜŒøœÅœÑœéŒ∏Œ∑Œ∫Œµ!";
                    }
                } catch (err) {
                    showError("Œ£œÜŒ¨ŒªŒºŒ± Œ±ŒΩŒ¨ŒªœÖœÉŒ∑œÇ KML: " + err.message);
                }
            };
            reader.onerror = function() {
                showError("Œ£œÜŒ¨ŒªŒºŒ± Œ±ŒΩŒ¨Œ≥ŒΩœâœÉŒ∑œÇ Œ±œÅœáŒµŒØŒøœÖ!");
            };
            reader.readAsText(file);
        }
        
        // Handle KML URL loading
        function handleUrlLoad() {
            const url = urlInput.value.trim();
            if (!url) {
                showError("Œ†Œ±œÅŒ±Œ∫Œ±Œªœé ŒµŒπœÉŒ¨Œ≥ŒµœÑŒµ Œ≠ŒΩŒ± URL!");
                return;
            }
            
            statusEl.textContent = "‚è≥ ŒõŒÆœàŒ∑ KML...";
            
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(kmlText => {
                    try {
                        const polygons = parseKML(kmlText);
                        if (!polygons || polygons.length === 0) {
                            showError("ŒîŒµŒΩ Œ≤œÅŒ≠Œ∏Œ∑Œ∫Œ±ŒΩ œÄŒøŒªœçŒ≥œâŒΩŒ± œÉœÑŒø KML!");
                        } else {
                            renderPolygons(polygons);
                            statusEl.textContent = "‚úÖ KML œÜŒøœÅœÑœéŒ∏Œ∑Œ∫Œµ!";
                        }
                    } catch (err) {
                        showError("Œ£œÜŒ¨ŒªŒºŒ± Œ±ŒΩŒ¨ŒªœÖœÉŒ∑œÇ KML: " + err.message);
                    }
                })
                .catch(error => {
                    showError("Œ£œÜŒ¨ŒªŒºŒ± ŒªŒÆœàŒ∑œÇ KML: " + error.message);
                });
        }
        
        // Parse KML to extract polygons
        function parseKML(kmlText) {
            const parser = new DOMParser();
            const kmlDoc = parser.parseFromString(kmlText, "text/xml");
            
            // Detect parsing errors
            const parserError = kmlDoc.getElementsByTagName('parsererror');
            if (parserError.length > 0) {
                throw new Error("ŒúŒ∑ Œ≠Œ≥Œ∫œÖœÅŒø XML!");
            }
            
            const polygons = [];
            
            // Look for different geometries
            // 1. Standard Polygons
            const placemarks = kmlDoc.getElementsByTagName('Placemark');
            for (let i = 0; i < placemarks.length; i++) {
                const placemark = placemarks[i];
                
                // Get placemark name if available
                const nameEl = placemark.getElementsByTagName('name')[0];
                const name = nameEl ? nameEl.textContent : "Polygon " + (i + 1);
                
                // Check for direct Polygon elements
                const polygonElements = placemark.getElementsByTagName('Polygon');
                for (let j = 0; j < polygonElements.length; j++) {
                    const polygon = polygonElements[j];
                    const coordsElements = polygon.getElementsByTagName('coordinates');
                    
                    if (coordsElements.length > 0) {
                        const coordsText = coordsElements[0].textContent.trim();
                        const coords = parseCoordinateString(coordsText);
                        
                        if (coords.length > 2) {
                            polygons.push({
                                type: 'polygon',
                                name: name,
                                points: coords
                            });
                        }
                    }
                }
                
                // Check for LineStrings
                const lineElements = placemark.getElementsByTagName('LineString');
                for (let j = 0; j < lineElements.length; j++) {
                    const line = lineElements[j];
                    const coordsElements = line.getElementsByTagName('coordinates');
                    
                    if (coordsElements.length > 0) {
                        const coordsText = coordsElements[0].textContent.trim();
                        const coords = parseCoordinateString(coordsText);
                        
                        if (coords.length > 1) {
                            polygons.push({
                                type: 'line',
                                name: name,
                                points: coords
                            });
                        }
                    }
                }
                
                // Check for Points
                const pointElements = placemark.getElementsByTagName('Point');
                for (let j = 0; j < pointElements.length; j++) {
                    const point = pointElements[j];
                    const coordsElements = point.getElementsByTagName('coordinates');
                    
                    if (coordsElements.length > 0) {
                        const coordsText = coordsElements[0].textContent.trim();
                        const coords = parseCoordinateString(coordsText);
                        
                        if (coords.length > 0) {
                            polygons.push({
                                type: 'point',
                                name: name,
                                points: coords
                            });
                        }
                    }
                }
                
                // Check for MultiGeometry (could contain multiple geometries)
                const multiGeoElements = placemark.getElementsByTagName('MultiGeometry');
                for (let j = 0; j < multiGeoElements.length; j++) {
                    const multiGeo = multiGeoElements[j];
                    
                    // Check for polygons inside MultiGeometry
                    const multiPolygons = multiGeo.getElementsByTagName('Polygon');
                    for (let k = 0; k < multiPolygons.length; k++) {
                        const polygon = multiPolygons[k];
                        const coordsElements = polygon.getElementsByTagName('coordinates');
                        
                        if (coordsElements.length > 0) {
                            const coordsText = coordsElements[0].textContent.trim();
                            const coords = parseCoordinateString(coordsText);
                            
                            if (coords.length > 2) {
                                polygons.push({
                                    type: 'polygon',
                                    name: name,
                                    points: coords
                                });
                            }
                        }
                    }
                    
                    // Similar checks for LineString and Point in MultiGeometry
                    // (code omitted for brevity but follows same pattern)
                }
            }
            
            return polygons;
        }
        
        // Parse coordinate string into array of lat/lon objects
        function parseCoordinateString(coordsText) {
            const coordinates = [];
            const coordPairs = coordsText.split(/\s+/);
            
            for (let i = 0; i < coordPairs.length; i++) {
                const pair = coordPairs[i].trim();
                if (!pair) continue;
                
                const coords = pair.split(',');
                if (coords.length >= 2) {
                    const lon = parseFloat(coords[0]);
                    const lat = parseFloat(coords[1]);
                    
                    if (!isNaN(lon) && !isNaN(lat)) {
                        coordinates.push({ lat, lon });
                    }
                }
            }
            
            return coordinates;
        }
        
        // Render polygons in AR
        function renderPolygons(polygons) {
            // Clear existing elements
            kmlContainer.innerHTML = '';
            
            polygons.forEach((polygon, index) => {
                if (polygon.type === 'polygon') {
                    renderPolygon(polygon, index);
                } else if (polygon.type === 'line') {
                    renderLine(polygon, index);
                } else if (polygon.type === 'point') {
                    renderPoint(polygon, index);
                }
            });
        }
        
        // Render polygon
        function renderPolygon(polygon, index) {
            const points = polygon.points;
            
            // Create lines for polygon edges
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                
                // Create a line entity
                const line = document.createElement('a-entity');
                line.setAttribute('gps-entity-place', `latitude: ${p1.lat}; longitude: ${p1.lon}`);
                line.setAttribute('line', {
                    start: '0 0 0',
                    end: `${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).x} 0 ${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).z}`,
                    color: 'red',
                    opacity: 0.8,
                    width: 5
                });
                kmlContainer.appendChild(line);
            }
            
            // Create a semi-transparent fill for the polygon
            // Calculate center point of polygon
            let avgLat = 0, avgLon = 0;
            points.forEach(p => {
                avgLat += p.lat;
                avgLon += p.lon;
            });
            avgLat /= points.length;
            avgLon /= points.length;
            
            // Calculate approximate size of polygon (simplified)
            let maxDistance = 0;
            points.forEach(p => {
                const distance = geoDistance(avgLat, avgLon, p.lat, p.lon);
                if (distance > maxDistance) maxDistance = distance;
            });
            
            // Create polygon fill as a plane
            const fill = document.createElement('a-entity');
            fill.setAttribute('gps-entity-place', `latitude: ${avgLat}; longitude: ${avgLon}`);
            fill.setAttribute('geometry', {
                primitive: 'plane',
                width: maxDistance * 2,
                height: maxDistance * 2
            });
            fill.setAttribute('material', {
                color: 'blue',
                opacity: 0.3,
                transparent: true,
                side: 'double'
            });
            fill.setAttribute('rotation', '-90 0 0');
            kmlContainer.appendChild(fill);
            
            // Add text label with the name
            const text = document.createElement('a-text');
            text.setAttribute('gps-entity-place', `latitude: ${avgLat}; longitude: ${avgLon}`);
            text.setAttribute('value', polygon.name);
            text.setAttribute('scale', '5 5 5');
            text.setAttribute('look-at', '[gps-camera]');
            text.setAttribute('align', 'center');
            text.setAttribute('color', 'white');
            text.setAttribute('position', '0 10 0');
            kmlContainer.appendChild(text);
        }
        
        // Render line
        function renderLine(line, index) {
            const points = line.points;
            
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];
                
                const lineEntity = document.createElement('a-entity');
                lineEntity.setAttribute('gps-entity-place', `latitude: ${p1.lat}; longitude: ${p1.lon}`);
                lineEntity.setAttribute('line', {
                    start: '0 0 0',
                    end: `${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).x} 0 ${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).z}`,
                    color: 'green',
                    opacity: 0.8,
                    width: 3
                });
                kmlContainer.appendChild(lineEntity);
            }
            
            // Add label at the center of the line
            if (points.length > 0) {
                const midPoint = points[Math.floor(points.length / 2)];
                const text = document.createElement('a-text');
                text.setAttribute('gps-entity-place', `latitude: ${midPoint.lat}; longitude: ${midPoint.lon}`);
                text.setAttribute('value', line.name);
                text.setAttribute('scale', '5 5 5');
                text.setAttribute('look-at', '[gps-camera]');
                text.setAttribute('align', 'center');
                text.setAttribute('color', 'white');
                text.setAttribute('position', '0 10 0');
                kmlContainer.appendChild(text);
            }
        }
        
        // Render point
        function renderPoint(point, index) {
            if (point.points.length > 0) {
                const p = point.points[0];
                
                // Create a sphere for the point
                const sphere = document.createElement('a-sphere');
                sphere.setAttribute('gps-entity-place', `latitude: ${p.lat}; longitude: ${p.lon}`);
                sphere.setAttribute('color', 'yellow');
                sphere.setAttribute('radius', '2');
                sphere.setAttribute('position', '0 0 0');
                kmlContainer.appendChild(sphere);
                
                // Add label
                const text = document.createElement('a-text');
                text.setAttribute('gps-entity-place', `latitude: ${p.lat}; longitude: ${p.lon}`);
                text.setAttribute('value', point.name);
                text.setAttribute('scale', '5 5 5');
                text.setAttribute('look-at', '[gps-camera]');
                text.setAttribute('align', 'center');
                text.setAttribute('color', 'white');
                text.setAttribute('position', '0 10 0');
                kmlContainer.appendChild(text);
            }
        }
        
        // Toggle AR visibility
        function toggleARVisibility() {
            arVisible = !arVisible;
            kmlContainer.setAttribute('visible', arVisible);
            toggleBtn.textContent = arVisible ? 'ŒëœÄœåŒ∫œÅœÖœàŒ∑ AR' : 'ŒïŒºœÜŒ¨ŒΩŒπœÉŒ∑ AR';
        }
        
        // Reset AR scene
        function resetAR() {
            kmlContainer.innerHTML = '';
            statusEl.textContent = "AR ŒµœÄŒ±ŒΩŒ±œÜŒ≠œÅŒ∏Œ∑Œ∫Œµ";
        }
        
        // Show error message
        function showError(message) {
            errorMessageEl.textContent = message;
            errorMessageEl.style.display = 'block';
            setTimeout(() => {
                errorMessageEl.style.display = 'none';
            }, 5000);
            statusEl.textContent = "‚ùå Œ£œÜŒ¨ŒªŒºŒ±!";
        }
        
        // Convert geo coordinates to meters relative to a reference point
        function geoToMeters(lat1, lon1, lat2, lon2) {
            const R = 6378137; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const distance = R * c;
            
            // Calculate x and z components
            const y = 0; // y is always 0 for our ground-level features
            const bearing = Math.atan2(
                Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180),
                Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
                Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon)
            );
            
            const x = distance * Math.sin(bearing);
            const z = distance * Math.cos(bearing);
            
            return { x, y, z };
        }
        
        // Calculate geodesic distance between two points
        function geoDistance(lat1, lon1, lat2, lon2) {
            const R = 6378137; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // AR scene initialization and location handling
        document.addEventListener('DOMContentLoaded', () => {
            const camera = document.querySelector('a-camera');
            
            // When we get GPS position
            camera.addEventListener('gps-camera-update-position', e => {
                userPosition = e.detail.position;
                statusEl.textContent = "‚úÖ GPS ŒµŒΩŒµœÅŒ≥œå";
                
                // Update accuracy display
                if (e.detail.accuracy) {
                    currentAccuracy = e.detail.accuracy;
                    accuracyEl.textContent = `ŒëŒ∫œÅŒØŒ≤ŒµŒπŒ± GPS: ¬±${currentAccuracy.toFixed(2)}m`;
                    
                    // Change color based on accuracy
                    if (currentAccuracy <= 10) {
                        accuracyEl.style.color = 'green';
                    } else if (currentAccuracy <= 20) {
                        accuracyEl.style.color = 'orange';
                    } else {
                        accuracyEl.style.color = 'red';
                    }
                }
            });
            
            // Touch event for placing markers
            document.addEventListener('touchend', e => {
                if (arVisible && userPosition) {
                    // Place a marker where user taps
                    const touchX = e.changedTouches[0].clientX;
                    const touchY = e.changedTouches[0].clientY;
                    
                    // Create a marker that is placed slightly in front of the user
                    const marker = document.createElement('a-sphere');
                    marker.setAttribute('gps-entity-place', `latitude: ${userPosition.latitude}; longitude: ${userPosition.longitude}`);
                    marker.setAttribute('color', 'red');
                    marker.setAttribute('radius', '1');
                    marker.setAttribute('position', '0 0 -10');
                    kmlContainer.appendChild(marker);
                    
                    // Show feedback
                    statusEl.textContent = "üìç ŒîŒµŒØŒ∫œÑŒ∑œÇ œÑŒøœÄŒøŒ∏ŒµœÑŒÆŒ∏Œ∑Œ∫Œµ";
                }
            });
        });
    </script>
</body>
</html>
