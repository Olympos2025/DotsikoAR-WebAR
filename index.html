<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebAR KML Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <!-- A-Frame core -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <!-- AR.js location-based -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
  <!-- Polygon component for A‑Frame -->
  <script src="https://unpkg.com/aframe-polygon-component@3.0.0/dist/aframe-polygon-component.min.js"></script>
  <style>
    body { margin:0; overflow:hidden; }
    #startAR {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      padding: 1em; font-size: 1.2em;
      z-index: 999;
    }
    #fileInput {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(255,255,255,0.8);
      padding: 6px; border-radius: 4px;
      z-index: 999;
      display: none;
    }
    #arScene { display: none; }
  </style>
</head>
<body>
  <!-- Κουμπί εκκίνησης AR (motion permission iOS) -->
  <button id="startAR">Start AR</button>
  <!-- Επιλογή πολλαπλών KML -->
  <input type="file" id="fileInput" accept=".kml" multiple />

  <!-- AR σκηνή -->
  <a-scene id="arScene"
    embedded vr-mode-ui="enabled:false"
    arjs="sourceType:camera; debugUIEnabled:false;
          gpsMinDistance:0; gpsMaxDistance:20000;">
    <a-camera gps-camera rotation-reader></a-camera>
  </a-scene>

  <script>
  document.getElementById('startAR').addEventListener('click', async () => {
    // Ζητάμε permission για device orientation σε iOS
    if (DeviceOrientationEvent?.requestPermission) {
      try {
        const state = await DeviceOrientationEvent.requestPermission();
        if (state !== 'granted') {
          alert('Motion permission required for AR');
          return;
        }
      } catch(e) {
        console.warn('DeviceOrientation permission error', e);
      }
    }
    // Κρύβουμε το κουμπί, εμφανίζουμε fileInput & AR scene
    document.getElementById('startAR').style.display = 'none';
    document.getElementById('fileInput').style.display = 'block';
    document.getElementById('arScene').style.display = 'block';
  });

  document.addEventListener('DOMContentLoaded', () => {
    const sceneEl = document.querySelector('a-scene');
    const fileInput = document.getElementById('fileInput');
    const maxDistance = 20000; // μέτρα

    // Υπολογισμός απόστασης Haversine
    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000, toRad = d => d * Math.PI/180;
      const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // Προσθήκη σημείου
    function addPoint(lat, lon, alt=0) {
      const s = document.createElement('a-sphere');
      s.setAttribute('gps-entity-place',
        `latitude:${lat};longitude:${lon};altitude:${alt};`);
      s.setAttribute('radius','2');
      s.setAttribute('color','#FF0000');
      s.setAttribute('opacity','0.8');
      sceneEl.appendChild(s);
    }

    // Προσθήκη γραμμής
    function addLine(p1, p2) {
      const e = document.createElement('a-entity');
      e.setAttribute('gps-entity-place',
        `latitude:${p1.lat};longitude:${p1.lon};altitude:${p1.alt};`);
      e.setAttribute('line', {
        start: '0 0 0',
        end: `${p2.lon-p1.lon} 0 ${p2.lat-p1.lat}`,
        color: '#00FF00'
      });
      sceneEl.appendChild(e);
    }

    // Προσθήκη γεμισμένου πολυγώνου
    function addPolygon(pts) {
      const poly = document.createElement('a-entity');
      poly.setAttribute('gps-entity-place',
        `latitude:${pts[0].lat};longitude:${pts[0].lon};altitude:${pts[0].alt};`);
      const verts = pts.map(p => `${p.lon},${p.lat}`).join(' ');
      poly.setAttribute('polygon', {
        vertices: verts,
        color: '#0000FF',
        opacity: 0.4
      });
      sceneEl.appendChild(poly);
    }

    // Φόρτωση KML σε XML, parsing και rendering
    function parseKMLandRender(text) {
      const xml = new DOMParser().parseFromString(text,'application/xml');
      const placemarks = xml.getElementsByTagName('Placemark');
      navigator.geolocation.getCurrentPosition(pos => {
        const uLat = pos.coords.latitude, uLon = pos.coords.longitude;
        Array.from(placemarks).forEach(pm => {
          const tag = pm.querySelector('Polygon coordinates,LineString coordinates,Point coordinates');
          if (!tag) return;
          const raw = tag.textContent.trim().split(/\s+/).map(str => {
            const [lon, lat, alt=0] = str.split(',').map(Number);
            return {lat, lon, alt};
          });
          // φιλτράρισμα απόστασης
          if (getDistance(uLat,uLon,raw[0].lat,raw[0].lon) > maxDistance) return;
          if (pm.querySelector('Point')) {
            addPoint(raw[0].lat, raw[0].lon, raw[0].alt);
          } else if (pm.querySelector('LineString')) {
            for (let i=0; i<raw.length-1; i++) addLine(raw[i], raw[i+1]);
          } else if (pm.querySelector('Polygon')) {
            addPolygon(raw);
          }
        });
      }, err => console.error(err), { enableHighAccuracy: true });
    }

    // Φόρτωση bundled thermi.kml
    fetch('thermi.kml')
      .then(r => r.text())
      .then(parseKMLandRender)
      .catch(console.error);

    // Όταν ανεβαίνουν user‐selected αρχεία
    fileInput.addEventListener('change', e => {
      Array.from(e.target.files).forEach(file => {
        const reader = new FileReader();
        reader.onload = () => parseKMLandRender(reader.result);
        reader.readAsText(file);
      });
    });
  });
  </script>
</body>
</html>
