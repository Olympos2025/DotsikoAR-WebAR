<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="utf-8">
  <title>MapLens</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <!-- A-Frame & AR.js -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700;400&display=swap" rel="stylesheet">
  <!-- Feather Icons for SVGs -->
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
  <style>
    :root {
      --primary: #2D9CDB;
      --secondary: #56CCF2;
      --accent: #6FCF97;
      --background: #F7FAFC;
      --background-dark: #181D27;
      --glass: rgba(255,255,255,0.82);
      --glass-dark: rgba(24,29,39,0.85);
      --radius: 22px;
      --sidebar-width: 340px;
      --frame-thickness: 20px;
      --tick-spacing: 36px;
      --tick-length: 10px;
      --neumorph-shadow: 0 2px 12px 0 rgba(44,62,80,0.11);
      --duration: 0.35s;
      --blur: 18px;
      --font-main: 'Inter', system-ui, sans-serif;
    }
    html, body {
      margin: 0; padding: 0;
      font-family: var(--font-main);
      background: var(--background);
      color: #222B45;
      min-height: 100vh;
      transition: background 0.3s, color 0.3s;
      overflow: hidden;
    }
    body.dark {
      background: var(--background-dark);
      color: #e7eaf1;
    }
    /* Frame/Grid */
    .frame-container {
      position: fixed; inset: 0; z-index: 9998; pointer-events: none;
      background:
        linear-gradient(to right, var(--primary) 1px, transparent 1px) repeat-x,
        linear-gradient(to bottom, var(--primary) 1px, transparent 1px) repeat-y;
      background-size: var(--tick-spacing) var(--tick-spacing);
      border: var(--frame-thickness) solid rgba(45,156,219,0.18);
      border-radius: var(--radius);
      box-sizing: border-box;
      transition: border-color 0.3s;
    }
    body.dark .frame-container {
      border-color: rgba(86,204,242,0.17);
      background:
        linear-gradient(to right, var(--secondary) 1px, transparent 1px) repeat-x,
        linear-gradient(to bottom, var(--secondary) 1px, transparent 1px) repeat-y;
    }
    /* Tick marks */
    .tick-marks { position: absolute; inset: 0; pointer-events: none; }
    .tick-mark {
      position: absolute; background: var(--primary); opacity: 0.21;
      z-index: 9999; border-radius: 2px;
      transition: background 0.3s;
    }
    .tick-mark.h { width: 2px; height: var(--tick-length);}
    .tick-mark.v { height: 2px; width: var(--tick-length);}
    body.dark .tick-mark { background: var(--secondary);}
    /* Hamburger */
    #menu-toggle {
      position: fixed;
      top: calc(var(--frame-thickness) + 12px);
      left: calc(var(--frame-thickness) + 12px);
      z-index: 10000;
      width: 44px; height: 44px;
      background: var(--glass); border: none;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      box-shadow: var(--neumorph-shadow);
      cursor: pointer;
      transition: background 0.25s, box-shadow 0.25s, transform 0.15s;
      outline: none;
      will-change: background, box-shadow;
    }
    body.dark #menu-toggle { background: var(--glass-dark);}
    #menu-toggle .hamburger {
      width: 26px; height: 26px; display: block; position: relative;
      transition: transform 0.25s;
    }
    .hamburger span {
      display: block; position: absolute; left: 0; width: 100%; height: 4px;
      background: var(--primary); border-radius: 2px;
      transition: all 0.3s cubic-bezier(.77,0,.18,1);
    }
    .hamburger span:nth-child(1) { top: 0; }
    .hamburger span:nth-child(2) { top: 11px; }
    .hamburger span:nth-child(3) { top: 22px; }
    #menu-toggle.open .hamburger span:nth-child(1) {
      top: 11px; transform: rotate(45deg);
    }
    #menu-toggle.open .hamburger span:nth-child(2) { opacity: 0; }
    #menu-toggle.open .hamburger span:nth-child(3) {
      top: 11px; transform: rotate(-45deg);
    }
    /* Language selector & dark mode */
    .top-controls {
      position: fixed;
      top: calc(var(--frame-thickness) + 12px);
      right: calc(var(--frame-thickness) + 12px);
      z-index: 10000;
      display: flex; gap: 8px;
      align-items: center;
    }
    .language-selector button, .dark-toggle {
      background: var(--glass);
      color: var(--primary);
      border: 1.5px solid var(--primary);
      border-radius: 12px;
      font-weight: 700;
      width: 38px; height: 32px;
      cursor: pointer;
      font-size: 1em;
      transition: background 0.2s, color 0.2s, border 0.2s;
      outline: none;
      display: flex; align-items: center; justify-content: center;
    }
    body.dark .language-selector button, body.dark .dark-toggle {
      background: var(--glass-dark); color: var(--secondary); border-color: var(--secondary);
    }
    .language-selector button.active {
      background: var(--primary); color: white; border-color: var(--secondary);
    }
    .dark-toggle svg { width: 20px; height: 20px; }
    /* Sidebar */
    .sidebar {
      position: fixed;
      top: var(--frame-thickness);
      left: var(--frame-thickness);
      height: calc(100vh - var(--frame-thickness)*2);
      width: var(--sidebar-width);
      background: var(--glass);
      backdrop-filter: blur(var(--blur));
      border-radius: var(--radius);
      box-shadow: 0 8px 32px 0 rgba(44,62,80,0.13);
      z-index: 9999;
      transform: translateX(-120%);
      transition: transform var(--duration) cubic-bezier(.77,0,.18,1), background 0.3s;
      display: flex; flex-direction: column; gap: 18px;
      padding: 24px 20px 18px 20px;
      will-change: transform;
    }
    body.dark .sidebar { background: var(--glass-dark);}
    .sidebar.open { transform: translateX(0); }
    /* Logo */
    .app-logo { text-align: center; margin-bottom: 10px;}
    .logo-row {
      display: flex; align-items: center; justify-content: center; gap: 10px;
    }
    .logo-circle {
      width: 40px; height: 40px;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      border-radius: 50%;
      box-shadow: 0 2px 8px 0 var(--secondary);
      display: flex; align-items: center; justify-content: center;
      font-size: 1.4em; color: white; font-weight: 700;
      border: 2.5px solid #fff;
      letter-spacing: -1px;
      transition: background 0.3s;
    }
    .logo-text {
      font-size: 1.35em;
      font-weight: 700;
      letter-spacing: -1px;
      color: var(--primary);
      font-family: var(--font-main);
      text-transform: lowercase;
      margin-top: 2px;
      user-select: none;
    }
    body.dark .logo-text { color: var(--secondary);}
    .app-tagline {
      font-size: 1em;
      color: var(--secondary);
      opacity: 0.85;
      margin-bottom: 8px;
      font-style: italic;
      font-weight: 500;
      letter-spacing: 0.2px;
      user-select: none;
    }
    body.dark .app-tagline { color: var(--accent);}
    /* Panels */
    .panel {
      background: var(--glass);
      border-radius: var(--radius);
      box-shadow: var(--neumorph-shadow);
      padding: 13px 15px;
      margin-bottom: 6px;
      transition: background 0.3s;
    }
    body.dark .panel { background: var(--glass-dark);}
    /* Status */
    .status-list { list-style: none; padding: 0; margin: 0;}
    .status-list li {
      display: flex; align-items: center; gap: 10px;
      font-size: 1em; margin-bottom: 4px;
    }
    .status-list li:last-child { margin-bottom: 0;}
    .status-icon {
      font-size: 1.1em;
      color: var(--primary);
      display: flex; align-items: center; justify-content: center;
      width: 1.5em; height: 1.5em;
    }
    body.dark .status-icon { color: var(--secondary);}
    .accuracy-badge {
      padding: 2px 10px;
      border-radius: 12px;
      font-size: 0.95em;
      font-weight: 600;
      margin-left: 4px;
      background: var(--secondary);
      color: white;
      transition: background 0.2s;
    }
    /* Inputs & Buttons */
    input[type="text"] {
      width: 100%;
      padding: 8px 12px;
      border: 1.5px solid var(--primary);
      border-radius: 12px;
      font-size: 1em;
      margin-bottom: 7px;
      background: rgba(255,255,255,0.93);
      color: var(--dark);
      transition: border 0.2s, background 0.2s, color 0.2s;
      outline: none;
    }
    body.dark input[type="text"] {
      background: rgba(24,29,39,0.93); color: #e7eaf1; border-color: var(--secondary);
    }
    input[type="text"]:focus {
      border-color: var(--secondary);
    }
    .btn {
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 1em;
      font-weight: 700;
      padding: 10px 0;
      margin: 4px 0;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(44,62,80,0.10);
      transition: background 0.22s, box-shadow 0.22s, transform 0.11s;
      text-transform: uppercase;
      letter-spacing: 1px;
      outline: none;
    }
    .btn:active { background: var(--secondary); transform: scale(0.97);}
    .btn-alt {
      background: white;
      color: var(--primary);
      border: 1.5px solid var(--primary);
      box-shadow: none;
      text-transform: none;
    }
    body.dark .btn-alt {
      background: #232a37; color: var(--secondary); border-color: var(--secondary);
    }
    .btn:hover { filter: brightness(1.07);}
    .divider {
      text-align: center;
      color: var(--dark);
      opacity: 0.5;
      margin: 6px 0;
      font-size: 0.97em;
      user-select: none;
    }
    body.dark .divider { color: #e7eaf1;}
    .error-message {
      background: rgba(255, 61, 111, 0.16);
      color: #FF3D6F;
      border-radius: 12px;
      padding: 8px 12px;
      font-size: 1em;
      margin-top: 10px;
      display: none;
      transition: background 0.3s, color 0.3s;
    }
    /* Copyright */
    .copyright {
      position: fixed;
      bottom: calc(var(--frame-thickness) + 7px);
      right: calc(var(--frame-thickness) + 7px);
      font-size: 0.92em;
      color: var(--dark);
      opacity: 0.45;
      background: var(--glass);
      border-radius: 12px;
      padding: 6px 14px;
      z-index: 10000;
      box-shadow: 0 2px 8px rgba(44,62,80,0.06);
      pointer-events: none;
      transition: background 0.3s, color 0.3s;
    }
    body.dark .copyright { background: var(--glass-dark); color: #e7eaf1;}
    .copyright a { color: var(--primary); text-decoration: none;}
    .copyright a:hover { color: var(--accent);}
    /* Responsive */
    @media (max-width: 600px) {
      :root { --sidebar-width: 97vw; }
      .sidebar { padding: 12px 2vw 8px 2vw; }
      .logo-text { font-size: 1.1em;}
    }
    @media (max-width: 400px) {
      .sidebar { padding: 10px 1vw 6px 1vw;}
    }
    /* Accessibility focus */
    button:focus, input:focus { outline: 2px solid var(--primary);}
    body.dark button:focus, body.dark input:focus { outline: 2px solid var(--secondary);}
    /* Hide file input */
    #file-input { display: none;}
  </style>
</head>
<body>
  <div class="frame-container"></div>
  <div class="tick-marks" id="tick-marks"></div>
  <button id="menu-toggle" aria-label="Menu" aria-expanded="false">
    <span class="hamburger" aria-hidden="true">
      <span></span><span></span><span></span>
    </span>
  </button>
  <div class="top-controls">
    <div class="language-selector" role="radiogroup" aria-label="Language">
      <button id="lang-el" class="active" aria-pressed="true" aria-label="Ελληνικά">EL</button>
      <button id="lang-en" aria-pressed="false" aria-label="English">EN</button>
    </div>
    <button class="dark-toggle" id="dark-toggle" aria-label="Dark mode">
      <svg id="dark-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#2D9CDB" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z"/></svg>
    </button>
  </div>
  <div class="copyright">
    © 2025 Thomas G. Lagkas | <a href="mailto:Thomas.lagkas@outlook.com">Thomas.lagkas@outlook.com</a>
  </div>
  <div class="sidebar" id="sidebar" aria-label="Sidebar menu">
    <div class="app-logo">
      <div class="logo-row">
        <div class="logo-circle">M</div>
        <div class="logo-text">maplens</div>
      </div>
      <div class="app-tagline" data-el="Δες τον κόσμο αλλιώς" data-en="See the world differently">Δες τον κόσμο αλλιώς</div>
    </div>
    <div class="panel" aria-label="GPS status">
      <ul class="status-list">
        <li><span class="status-icon" data-feather="crosshair"></span><span id="status">⌛ Αναμονή GPS...</span></li>
        <li><span class="status-icon" data-feather="activity"></span><span id="accuracy">Ακρίβεια GPS: Αναμονή...</span></li>
        <li><span class="status-icon" data-feather="clock"></span><span id="datetime"></span></li>
      </ul>
    </div>
    <div class="panel" aria-label="KML import">
      <input type="file" id="file-input" accept=".kml">
      <button id="upload-btn" class="btn" data-el="Φόρτωση KML" data-en="Load KML" aria-label="Load KML">Φόρτωση KML</button>
      <div class="divider" data-el="ή" data-en="or">ή</div>
      <input type="text" id="url-input" placeholder="URL του KML αρχείου" data-el-placeholder="URL του KML αρχείου" data-en-placeholder="KML file URL" aria-label="KML file URL">
      <button id="load-url-btn" class="btn" data-el="Φόρτωση από URL" data-en="Load from URL" aria-label="Load from URL">Φόρτωση από URL</button>
    </div>
    <div class="panel" aria-label="AR controls">
      <button id="toggle-btn" class="btn" data-el="Εμφάνιση/Απόκρυψη AR" data-en="Show/Hide AR" aria-label="Toggle AR">Εμφάνιση/Απόκρυψη AR</button>
      <button id="reset-btn" class="btn btn-alt" data-el="Επαναφορά" data-en="Reset" aria-label="Reset AR">Επαναφορά</button>
    </div>
    <div id="error-message" class="error-message" role="alert"></div>
  </div>
  <a-scene 
    vr-mode-ui="enabled: false"
    arjs="sourceType: webcam; debugUIEnabled: false; sourceWidth: 1280; sourceHeight: 960;"
    renderer="logarithmicDepthBuffer: true; precision: medium;"
    embedded>
    <a-camera gps-camera rotation-reader></a-camera>
    <a-entity id="kml-container"></a-entity>
  </a-scene>
  <script>
    // Feather icons
    window.addEventListener('DOMContentLoaded', () => feather.replace());

    // Tick marks
    function createTickMarks() {
      const tickMarks = document.getElementById('tick-marks');
      tickMarks.innerHTML = '';
      const w = window.innerWidth, h = window.innerHeight;
      const frame = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--frame-thickness'));
      const spacing = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tick-spacing'));
      for (let x = frame; x < w - frame; x += spacing) {
        let t = document.createElement('div');
        t.className = 'tick-mark h'; t.style.top = frame + 'px'; t.style.left = x + 'px';
        tickMarks.appendChild(t);
        let b = document.createElement('div');
        b.className = 'tick-mark h'; b.style.bottom = frame + 'px'; b.style.left = x + 'px';
        tickMarks.appendChild(b);
      }
      for (let y = frame; y < h - frame; y += spacing) {
        let l = document.createElement('div');
        l.className = 'tick-mark v'; l.style.left = frame + 'px'; l.style.top = y + 'px';
        tickMarks.appendChild(l);
        let r = document.createElement('div');
        r.className = 'tick-mark v'; r.style.right = frame + 'px'; r.style.top = y + 'px';
        tickMarks.appendChild(r);
      }
    }
    window.addEventListener('resize', createTickMarks);
    window.addEventListener('DOMContentLoaded', createTickMarks);

    // Sidebar menu
    const menuToggle = document.getElementById('menu-toggle');
    const sidebar = document.getElementById('sidebar');
    menuToggle.addEventListener('click', () => {
      sidebar.classList.toggle('open');
      menuToggle.classList.toggle('open');
      menuToggle.setAttribute('aria-expanded', sidebar.classList.contains('open'));
    });

    // Dark mode toggle
    const darkToggle = document.getElementById('dark-toggle');
    const darkIcon = document.getElementById('dark-icon');
    function setDarkMode(on) {
      document.body.classList.toggle('dark', on);
      localStorage.setItem('maplens-dark', on ? '1' : '0');
      darkIcon.innerHTML = on
        ? '<circle cx="12" cy="12" r="5" fill="#56CCF2"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="#56CCF2" stroke-width="2" stroke-linecap="round"/>'
        : '<path d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 0 0 9.79 9.79z" stroke="#2D9CDB" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>';
    }
    darkToggle.addEventListener('click', () => setDarkMode(!document.body.classList.contains('dark')));
    // Init dark mode from localStorage
    window.addEventListener('DOMContentLoaded', () => {
      setDarkMode(localStorage.getItem('maplens-dark') === '1');
    });

    // Language switching
    let currentLanguage = 'el';
    const langEl = document.getElementById('lang-el');
    const langEn = document.getElementById('lang-en');
    langEl.addEventListener('click', () => setLanguage('el'));
    langEn.addEventListener('click', () => setLanguage('en'));
    function setLanguage(lang) {
      currentLanguage = lang;
      langEl.classList.toggle('active', lang === 'el');
      langEn.classList.toggle('active', lang === 'en');
      langEl.setAttribute('aria-pressed', lang === 'el');
      langEn.setAttribute('aria-pressed', lang === 'en');
      document.querySelectorAll('[data-el][data-en]').forEach(el => {
        el.textContent = el.getAttribute(`data-${lang}`);
      });
      document.querySelectorAll('[data-el-placeholder][data-en-placeholder]').forEach(el => {
        el.setAttribute('placeholder', el.getAttribute(`data-${lang}-placeholder`));
      });
    }

    // Date/time
    function updateDateTime() {
      document.getElementById('datetime').textContent =
        new Date().toLocaleString(currentLanguage === 'el' ? 'el-GR' : 'en-US');
      setTimeout(updateDateTime, 1000);
    }
    updateDateTime();

    // Translations
    const translations = {
      el: {
        waiting: "⌛ Αναμονή GPS...",
        active: "✅ GPS ενεργό",
        loading: "⏳ Φόρτωση KML...",
        loaded: "✅ KML φορτώθηκε!",
        error: "❌ Σφάλμα!",
        reset: "AR επαναφέρθηκε",
        accuracy: "Ακρίβεια GPS: ",
        notAvailable: "Ακρίβεια GPS: Μη διαθέσιμη",
        urlRequired: "Παρακαλώ εισάγετε ένα URL!",
        noPolygons: "Δεν βρέθηκαν πολύγωνα/γραμμές/σημεία στο KML!",
        invalidXml: "Μη έγκυρο XML!",
        readError: "Σφάλμα ανάγνωσης αρχείου!",
        parseError: "Σφάλμα ανάλυσης KML: ",
        downloadError: "Σφάλμα λήψης KML: ",
        meters: "m",
        hideAR: "Απόκρυψη AR",
        showAR: "Εμφάνιση AR"
      },
      en: {
        waiting: "⌛ Waiting for GPS...",
        active: "✅ GPS active",
        loading: "⏳ Loading KML...",
        loaded: "✅ KML loaded!",
        error: "❌ Error!",
        reset: "AR reset",
        accuracy: "GPS accuracy: ",
        notAvailable: "GPS accuracy: Not available",
        urlRequired: "Please enter a URL!",
        noPolygons: "No polygons/lines/points found in the KML!",
        invalidXml: "Invalid XML!",
        readError: "Error reading file!",
        parseError: "Error parsing KML: ",
        downloadError: "Error downloading KML: ",
        meters: "m",
        hideAR: "Hide AR",
        showAR: "Show AR"
      }
    };

    // Status update
    let arVisible = true, currentAccuracy = null, userPosition = null;
    const statusEl = document.getElementById('status');
    const accuracyEl = document.getElementById('accuracy');
    const toggleBtn = document.getElementById('toggle-btn');
    const resetBtn = document.getElementById('reset-btn');
    const errorMessageEl = document.getElementById('error-message');
    const kmlContainer = document.getElementById('kml-container');
    toggleBtn.addEventListener('click', () => {
      arVisible = !arVisible;
      kmlContainer.setAttribute('visible', arVisible);
      toggleBtn.textContent = arVisible ? translations[currentLanguage].hideAR : translations[currentLanguage].showAR;
      toggleBtn.setAttribute('aria-label', arVisible ? translations[currentLanguage].hideAR : translations[currentLanguage].showAR);
    });
    resetBtn.addEventListener('click', () => {
      kmlContainer.innerHTML = '';
      statusEl.textContent = translations[currentLanguage].reset;
    });

    // GPS status
    document.addEventListener('DOMContentLoaded', () => {
      const camera = document.querySelector('a-camera');
      camera.addEventListener('gps-camera-update-position', e => {
        userPosition = e.detail.position;
        statusEl.textContent = translations[currentLanguage].active;
        let acc = null;
        if (e.detail.position && e.detail.position.accuracy !== undefined) {
          acc = e.detail.position.accuracy;
        } else if (e.detail.accuracy !== undefined) {
          acc = e.detail.accuracy;
        }
        if (acc !== null) {
          currentAccuracy = acc;
          accuracyEl.textContent = `${translations[currentLanguage].accuracy}±${currentAccuracy.toFixed(2)}${translations[currentLanguage].meters}`;
          accuracyEl.className = 'accuracy-badge';
          if (currentAccuracy <= 10) accuracyEl.style.background = "#6FCF97";
          else if (currentAccuracy <= 20) accuracyEl.style.background = "#56CCF2";
          else accuracyEl.style.background = "#F2994A";
        } else {
          accuracyEl.textContent = translations[currentLanguage].notAvailable;
          accuracyEl.className = '';
        }
      });
    });

    // KML loading
    const fileInput = document.getElementById('file-input');
    const uploadBtn = document.getElementById('upload-btn');
    const urlInput = document.getElementById('url-input');
    const loadUrlBtn = document.getElementById('load-url-btn');
    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileUpload);
    loadUrlBtn.addEventListener('click', handleUrlLoad);

    function handleFileUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      statusEl.textContent = translations[currentLanguage].loading;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const polygons = parseKML(e.target.result);
          if (!polygons || polygons.length === 0) {
            showError(translations[currentLanguage].noPolygons);
          } else {
            renderPolygons(polygons);
            statusEl.textContent = translations[currentLanguage].loaded;
          }
        } catch (err) {
          showError(translations[currentLanguage].parseError + err.message);
        }
      };
      reader.onerror = function() {
        showError(translations[currentLanguage].readError);
      };
      reader.readAsText(file);
    }

    function handleUrlLoad() {
      const url = urlInput.value.trim();
      if (!url) {
        showError(translations[currentLanguage].urlRequired);
        return;
      }
      statusEl.textContent = translations[currentLanguage].loading;
      fetch(url)
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
          return response.text();
        })
        .then(kmlText => {
          try {
            const polygons = parseKML(kmlText);
            if (!polygons || polygons.length === 0) {
              showError(translations[currentLanguage].noPolygons);
            } else {
              renderPolygons(polygons);
              statusEl.textContent = translations[currentLanguage].loaded;
            }
          } catch (err) {
            showError(translations[currentLanguage].parseError + err.message);
          }
        })
        .catch(error => {
          showError(translations[currentLanguage].downloadError + error.message);
        });
    }

    function showError(message) {
      errorMessageEl.textContent = message;
      errorMessageEl.style.display = 'block';
      setTimeout(() => { errorMessageEl.style.display = 'none'; }, 5000);
      statusEl.textContent = translations[currentLanguage].error;
    }

    function parseKML(kmlText) {
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(kmlText, "text/xml");
      const parserError = kmlDoc.getElementsByTagName('parsererror');
      if (parserError.length > 0) throw new Error(translations[currentLanguage].invalidXml);
      const polygons = [];
      const placemarks = kmlDoc.getElementsByTagName('Placemark');
      for (let i = 0; i < placemarks.length; i++) {
        const placemark = placemarks[i];
        const nameEl = placemark.getElementsByTagName('name')[0];
        const name = nameEl ? nameEl.textContent : "Στοιχείο " + (i + 1);
        // Πολύγωνα
        const polygonElements = placemark.getElementsByTagName('Polygon');
        for (let j = 0; j < polygonElements.length; j++) {
          const polygon = polygonElements[j];
          const coordsElements = polygon.getElementsByTagName('coordinates');
          if (coordsElements.length > 0) {
            const coordsText = coordsElements[0].textContent.trim();
            const coords = parseCoordinateString(coordsText);
            if (coords.length > 2) {
              polygons.push({type: 'polygon', name, points: coords});
            }
          }
        }
        // Γραμμές
        const lineElements = placemark.getElementsByTagName('LineString');
        for (let j = 0; j < lineElements.length; j++) {
          const line = lineElements[j];
          const coordsElements = line.getElementsByTagName('coordinates');
          if (coordsElements.length > 0) {
            const coordsText = coordsElements[0].textContent.trim();
            const coords = parseCoordinateString(coordsText);
            if (coords.length > 1) {
              polygons.push({type: 'line', name, points: coords});
            }
          }
        }
        // Σημεία
        const pointElements = placemark.getElementsByTagName('Point');
        for (let j = 0; j < pointElements.length; j++) {
          const point = pointElements[j];
          const coordsElements = point.getElementsByTagName('coordinates');
          if (coordsElements.length > 0) {
            const coordsText = coordsElements[0].textContent.trim();
            const coords = parseCoordinateString(coordsText);
            if (coords.length > 0) {
              polygons.push({type: 'point', name, points: coords});
            }
          }
        }
      }
      return polygons;
    }
    function parseCoordinateString(coordsText) {
      const coordinates = [];
      const coordPairs = coordsText.split(/\s+/);
      for (let i = 0; i < coordPairs.length; i++) {
        const pair = coordPairs[i].trim();
        if (!pair) continue;
        const coords = pair.split(',');
        if (coords.length >= 2) {
          const lon = parseFloat(coords[0]);
          const lat = parseFloat(coords[1]);
          if (!isNaN(lon) && !isNaN(lat)) {
            coordinates.push({ lat, lon });
          }
        }
      }
      return coordinates;
    }
    function renderPolygons(polygons) {
      kmlContainer.innerHTML = '';
      polygons.forEach((polygon, index) => {
        if (polygon.type === 'polygon') {
          renderPolygon(polygon, index);
        } else if (polygon.type === 'line') {
          renderLine(polygon, index);
        } else if (polygon.type === 'point') {
          renderPoint(polygon, index);
        }
      });
    }
    function renderPolygon(polygon, index) {
      const points = polygon.points;
      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        const line = document.createElement('a-entity');
        line.setAttribute('gps-entity-place', `latitude: ${p1.lat}; longitude: ${p1.lon}`);
        line.setAttribute('line', {
          start: '0 0 0',
          end: `${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).x} 0 ${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).z}`,
          color: '#2D9CDB',
          opacity: 0.85,
          width: 6
        });
        kmlContainer.appendChild(line);
      }
      let avgLat = 0, avgLon = 0;
      points.forEach(p => { avgLat += p.lat; avgLon += p.lon; });
      avgLat /= points.length;
      avgLon /= points.length;
      let maxDistance = 0;
      points.forEach(p => {
        const distance = geoDistance(avgLat, avgLon, p.lat, p.lon);
        if (distance > maxDistance) maxDistance = distance;
      });
      const fill = document.createElement('a-entity');
      fill.setAttribute('gps-entity-place', `latitude: ${avgLat}; longitude: ${avgLon}`);
      fill.setAttribute('geometry', {
        primitive: 'plane',
        width: maxDistance * 2,
        height: maxDistance * 2
      });
      fill.setAttribute('material', {
        color: '#56CCF2',
        opacity: 0.25,
        transparent: true,
        side: 'double'
      });
      fill.setAttribute('rotation', '-90 0 0');
      kmlContainer.appendChild(fill);
      const text = document.createElement('a-text');
      text.setAttribute('gps-entity-place', `latitude: ${avgLat}; longitude: ${avgLon}`);
      text.setAttribute('value', polygon.name);
      text.setAttribute('scale', '7 7 7');
      text.setAttribute('look-at', '[gps-camera]');
      text.setAttribute('align', 'center');
      text.setAttribute('color', '#2D9CDB');
      text.setAttribute('position', '0 12 0');
      kmlContainer.appendChild(text);
    }
    function renderLine(line, index) {
      const points = line.points;
      for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i + 1];
        const lineEntity = document.createElement('a-entity');
        lineEntity.setAttribute('gps-entity-place', `latitude: ${p1.lat}; longitude: ${p1.lon}`);
        lineEntity.setAttribute('line', {
          start: '0 0 0',
          end: `${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).x} 0 ${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).z}`,
          color: '#6FCF97',
          opacity: 0.9,
          width: 4
        });
        kmlContainer.appendChild(lineEntity);
      }
      if (points.length > 0) {
        const midPoint = points[Math.floor(points.length / 2)];
        const text = document.createElement('a-text');
        text.setAttribute('gps-entity-place', `latitude: ${midPoint.lat}; longitude: ${midPoint.lon}`);
        text.setAttribute('value', line.name);
        text.setAttribute('scale', '6 6 6');
        text.setAttribute('look-at', '[gps-camera]');
        text.setAttribute('align', 'center');
        text.setAttribute('color', '#2D9CDB');
        text.setAttribute('position', '0 10 0');
        kmlContainer.appendChild(text);
      }
    }
    function renderPoint(point, index) {
      if (point.points.length > 0) {
        const p = point.points[0];
        const sphere = document.createElement('a-sphere');
        sphere.setAttribute('gps-entity-place', `latitude: ${p.lat}; longitude: ${p.lon}`);
        sphere.setAttribute('color', '#6FCF97');
        sphere.setAttribute('radius', '2.5');
        sphere.setAttribute('position', '0 0 0');
        kmlContainer.appendChild(sphere);
        const text = document.createElement('a-text');
        text.setAttribute('gps-entity-place', `latitude: ${p.lat}; longitude: ${p.lon}`);
        text.setAttribute('value', point.name);
        text.setAttribute('scale', '5 5 5');
        text.setAttribute('look-at', '[gps-camera]');
        text.setAttribute('align', 'center');
        text.setAttribute('color', '#2D9CDB');
        text.setAttribute('position', '0 8 0');
        kmlContainer.appendChild(text);
      }
    }
    function geoToMeters(lat1, lon1, lat2, lon2) {
      const R = 6378137;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      const distance = R * c;
      const bearing = Math.atan2(
        Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180),
        Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
        Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon)
      );
      const x = distance * Math.sin(bearing);
      const z = distance * Math.cos(bearing);
      return { x, y: 0, z };
    }
    function geoDistance(lat1, lon1, lat2, lon2) {
      const R = 6378137;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
  </script>
</body>
</html>
