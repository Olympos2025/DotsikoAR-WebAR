<!DOCTYPE html>

<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>MapLens - Location AR Viewer</title>

```
<!-- A-Frame and AR.js -->
<script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/three.js/build/ar-threex-location-only.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.js"></script>
<script src="https://unpkg.com/@tmcw/togeojson@5.8.1"></script>

<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        overflow: hidden;
        background: #000;
        height: 100vh;
        width: 100vw;
        position: fixed;
    }

    /* Controls */
    .controls {
        position: fixed;
        top: calc(env(safe-area-inset-top, 10px) + 10px);
        left: 10px;
        right: 10px;
        display: flex;
        gap: 8px;
        justify-content: center;
        z-index: 9999;
        flex-wrap: wrap;
    }

    .btn {
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        font-weight: 600;
        font-size: 12px;
        cursor: pointer;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        white-space: nowrap;
        min-height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .btn-primary { background: rgba(59, 130, 246, 0.9); }
    .btn-success { background: rgba(16, 185, 129, 0.9); }
    .btn-danger { background: rgba(239, 68, 68, 0.9); }

    .file-input {
        position: absolute;
        left: -9999px;
        opacity: 0;
        width: 0.1px;
        height: 0.1px;
    }

    /* Status */
    .status {
        position: fixed;
        top: calc(env(safe-area-inset-top, 10px) + 60px);
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 8px;
        padding: 8px;
        z-index: 9998;
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: calc(100vw - 20px);
    }

    .status-item {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 4px;
        font-size: 11px;
        color: white;
        white-space: nowrap;
    }

    .status-item:last-child { margin-bottom: 0; }

    .status-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #ef4444;
        flex-shrink: 0;
    }

    .status-dot.active {
        background: #10b981;
        box-shadow: 0 0 8px #10b981;
    }

    /* Info */
    .info {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 10px) + 10px);
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(15px);
        border-radius: 8px;
        padding: 12px;
        color: white;
        font-size: 13px;
        z-index: 9997;
        transform: translateY(calc(100% + 20px));
        transition: transform 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-height: calc(40vh - env(safe-area-inset-bottom, 0px) - 20px);
        overflow-y: auto;
    }

    .info.show { transform: translateY(0); }

    /* Debug */
    .debug {
        position: fixed;
        top: calc(env(safe-area-inset-top, 10px) + 120px);
        left: 10px;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        border-radius: 6px;
        padding: 6px;
        font-family: monospace;
        font-size: 9px;
        color: #00ff00;
        z-index: 9996;
        display: none;
        border: 1px solid rgba(0, 255, 0, 0.3);
        max-width: calc(100vw - 20px);
    }

    .debug.show { display: block; }

    .debug div {
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* A-Frame scene */
    a-scene {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        z-index: 1 !important;
    }

    /* Loading indicator */
    .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 16px;
        z-index: 9999;
        display: none;
        text-align: center;
    }

    .spinner {
        width: 30px;
        height: 30px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 8px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Error dialog */
    .error-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(239, 68, 68, 0.95);
        color: white;
        padding: 16px;
        border-radius: 8px;
        text-align: center;
        z-index: 10000;
        max-width: calc(100vw - 40px);
        max-height: calc(100vh - 40px);
        overflow-y: auto;
        display: none;
    }

    .error-dialog h3 {
        margin-bottom: 10px;
        font-size: 16px;
    }

    .error-dialog p {
        margin-bottom: 15px;
        font-size: 14px;
        line-height: 1.4;
    }

    .error-dialog button {
        padding: 8px 16px;
        background: white;
        color: #ef4444;
        border: none;
        border-radius: 4px;
        font-weight: 600;
        cursor: pointer;
        font-size: 14px;
    }

    /* Mobile specific adjustments */
    @media (max-width: 480px) {
        .controls {
            gap: 6px;
        }
        
        .btn {
            padding: 6px 10px;
            font-size: 11px;
            min-height: 32px;
        }
        
        .status {
            top: calc(env(safe-area-inset-top, 10px) + 50px);
            padding: 6px;
        }
        
        .status-item {
            font-size: 10px;
            margin-bottom: 3px;
        }
        
        .debug {
            top: calc(env(safe-area-inset-top, 10px) + 100px);
            font-size: 8px;
            padding: 4px;
        }
        
        .info {
            font-size: 12px;
            padding: 10px;
        }
    }

    /* Landscape orientation adjustments */
    @media (orientation: landscape) and (max-height: 500px) {
        .controls {
            top: calc(env(safe-area-inset-top, 5px) + 5px);
            gap: 4px;
        }
        
        .btn {
            padding: 4px 8px;
            font-size: 10px;
            min-height: 28px;
        }
        
        .status {
            top: calc(env(safe-area-inset-top, 5px) + 35px);
            padding: 4px;
        }
        
        .status-item {
            font-size: 9px;
            margin-bottom: 2px;
        }
        
        .info {
            max-height: calc(30vh - env(safe-area-inset-bottom, 0px) - 10px);
            font-size: 11px;
            padding: 8px;
        }
        
        .debug {
            top: calc(env(safe-area-inset-top, 5px) + 70px);
            font-size: 7px;
        }
    }

    /* iOS Safari specific fixes */
    @supports (-webkit-touch-callout: none) {
        body {
            /* Fix for iOS Safari viewport issues */
            height: -webkit-fill-available;
        }
        
        .info {
            /* Extra padding for iOS safe area */
            bottom: calc(env(safe-area-inset-bottom, 20px) + 10px);
        }
    }

    /* Hide elements that might overflow */
    .controls, .status, .info, .debug, .loading, .error-dialog {
        contain: layout;
    }
</style>
```

</head>

<body>
    <!-- Controls -->
    <div class="controls">
        <input type="file" id="kml-input" class="file-input" accept=".kml,.kmz" multiple>
        <label for="kml-input" class="btn btn-primary">ğŸ“ Î¦ÏŒÏÏ„Ï‰ÏƒÎ· KML</label>
        <button id="debug-btn" class="btn">ğŸ”§ Debug</button>
        <button id="clear-btn" class="btn btn-danger">ğŸ—‘ï¸ ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚</button>
    </div>

```
<!-- Status Panel -->
<div class="status">
    <div class="status-item">
        <span class="status-dot" id="camera-dot"></span>
        <span id="camera-text">ÎšÎ¬Î¼ÎµÏÎ±</span>
    </div>
    <div class="status-item">
        <span class="status-dot" id="gps-dot"></span>
        <span id="gps-text">GPS</span>
    </div>
    <div class="status-item">
        <span class="status-dot" id="orientation-dot"></span>
        <span id="orientation-text">Î ÏÎ¿ÏƒÎ±Î½Î±Ï„Î¿Î»Î¹ÏƒÎ¼ÏŒÏ‚</span>
    </div>
    <div class="status-item">
        <span class="status-dot" id="features-dot"></span>
        <span id="features-text">Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î±: 0</span>
    </div>
</div>

<!-- Debug Panel -->
<div class="debug" id="debug-panel">
    <div>GPS: <span id="debug-gps">Î‘Î½Î±Î¼Î¿Î½Î®...</span></div>
    <div>Heading: <span id="debug-heading">Î‘Î½Î±Î¼Î¿Î½Î®...</span></div>
    <div>Accuracy: <span id="debug-accuracy">Î‘Î½Î±Î¼Î¿Î½Î®...</span></div>
    <div>Features: <span id="debug-features">0</span></div>
    <div>AR Objects: <span id="debug-objects">0</span></div>
</div>

<!-- Info Panel -->
<div class="info" id="info">
    Î‘ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ· MapLens...
</div>

<!-- Loading -->
<div class="loading" id="loading">
    <div class="spinner"></div>
    <div>Î¦ÏŒÏÏ„Ï‰ÏƒÎ·...</div>
</div>

<!-- Error Dialog -->
<div class="error-dialog" id="error-dialog">
    <h3>Î£Ï†Î¬Î»Î¼Î±</h3>
    <p id="error-text"></p>
    <button onclick="hideError()">OK</button>
</div>

<!-- AR Scene -->
<a-scene
    id="ar-scene"
    vr-mode-ui="enabled: false"
    arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
    renderer="logarithmicDepthBuffer: true; colorManagement: true; sortObjects: true; antialias: true; alpha: true;"
    embedded
    style="height: 100vh; width: 100vw;">
    
    <a-camera 
        id="ar-camera"
        gps-new-camera="gpsMinDistance: 1; gpsMaxDistance: 50000; positionMinAccuracy: 1000; alert: false; smoothingFactor: 0.05;"
        look-controls="enabled: false"
        wasd-controls="enabled: false"
        cursor="rayOrigin: mouse">
    </a-camera>
    
    <a-entity id="ar-objects"></a-entity>
</a-scene>

<script>
    class MapLensAR {
        constructor() {
            this.scene = document.getElementById('ar-scene');
            this.camera = document.getElementById('ar-camera');
            this.container = document.getElementById('ar-objects');
            this.features = [];
            this.userPosition = null;
            this.debugMode = false;
            
            this.init();
        }

        async init() {
            console.log('ğŸš€ MapLens AR initializing...');
            
            try {
                // Wait for scene to load
                await this.waitForScene();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Initialize location services
                this.initLocationServices();
                
                // Initialize orientation
                this.initOrientation();
                
                console.log('âœ… MapLens AR ready');
                this.showInfo('MapLens Î­Ï„Î¿Î¹Î¼Î¿! Î¦Î¿ÏÏ„ÏÏƒÏ„Îµ KML Î±ÏÏ‡ÎµÎ¯Î¿ Î³Î¹Î± Î½Î± Î´ÎµÎ¯Ï„Îµ AR ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±. Î£Î¥ÎœÎ’ÎŸÎ¥Î›Î—: Î’ÎµÎ²Î±Î¹Ï‰Î¸ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Î²ÏÎ¯ÏƒÎºÎµÏƒÏ„Îµ ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î·Î½ Ï€ÎµÏÎ¹Î¿Ï‡Î® Ï„Ï‰Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½ KML.');
                
            } catch (error) {
                console.error('âŒ Initialization failed:', error);
                this.showError(`Î£Ï†Î¬Î»Î¼Î± Î±ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ·Ï‚: ${error.message}`);
            }
        }

        waitForScene() {
            return new Promise((resolve) => {
                if (this.scene.hasLoaded) {
                    resolve();
                } else {
                    this.scene.addEventListener('loaded', resolve);
                }
            });
        }

        setupEventListeners() {
            // File input
            document.getElementById('kml-input').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    this.loadKMLFiles(e.target.files);
                }
            });

            // Debug toggle
            document.getElementById('debug-btn').addEventListener('click', () => {
                this.debugMode = !this.debugMode;
                document.getElementById('debug-panel').classList.toggle('show', this.debugMode);
                if (this.debugMode) {
                    this.updateDebugInfo();
                }
            });

            // Clear button
            document.getElementById('clear-btn').addEventListener('click', () => {
                this.clearAll();
            });

            // Scene events
            this.scene.addEventListener('enter-vr', () => {
                console.log('AR mode entered');
                this.updateStatus('camera', true, 'ÎšÎ¬Î¼ÎµÏÎ±: Î•Î½ÎµÏÎ³Î®');
            });

            this.scene.addEventListener('exit-vr', () => {
                console.log('AR mode exited');
            });

            // Camera ready detection
            this.scene.addEventListener('loaded', () => {
                setTimeout(() => {
                    this.updateStatus('camera', true, 'ÎšÎ¬Î¼ÎµÏÎ±: Î•Î½ÎµÏÎ³Î®');
                }, 2000);
            });
        }

        initLocationServices() {
            if (!navigator.geolocation) {
                this.updateStatus('gps', false, 'GPS: ÎœÎ· Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿');
                this.showError('GPS Î´ÎµÎ½ Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶ÎµÏ„Î±Î¹ ÏƒÎµ Î±Ï…Ï„Î® Ï„Î· ÏƒÏ…ÏƒÎºÎµÏ…Î®');
                return;
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 30000,
                maximumAge: 10000
            };

            // Watch position
            this.gpsWatchId = navigator.geolocation.watchPosition(
                (position) => this.handleGPSSuccess(position),
                (error) => this.handleGPSError(error),
                options
            );

            console.log('ğŸ“ GPS watch started');
        }

        handleGPSSuccess(position) {
            this.userPosition = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                altitude: position.coords.altitude || 0,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp
            };

            this.updateStatus('gps', true, `GPS: Â±${Math.round(position.coords.accuracy)}m`);

            if (this.debugMode) {
                document.getElementById('debug-gps').textContent = 
                    `${this.userPosition.latitude.toFixed(6)}, ${this.userPosition.longitude.toFixed(6)}`;
                document.getElementById('debug-accuracy').textContent = 
                    `Â±${Math.round(position.coords.accuracy)}m`;
            }

            console.log('ğŸ“ GPS updated:', this.userPosition);
        }

        handleGPSError(error) {
            console.error('âŒ GPS error:', error);
            
            let message = 'GPS: Î£Ï†Î¬Î»Î¼Î±';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message = 'GPS: Î‘Ï€Î¿ÏÏÎ¯Ï†Î¸Î·ÎºÎµ';
                    this.showError('Î Î±ÏÎ±ÎºÎ±Î»Ï ÎµÏ€Î¹Ï„ÏÎ­ÏˆÏ„Îµ Ï„Î·Î½ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î·Î½ Ï„Î¿Ï€Î¿Î¸ÎµÏƒÎ¯Î± ÏƒÏ„Î¹Ï‚ ÏÏ…Î¸Î¼Î¯ÏƒÎµÎ¹Ï‚ Ï„Î¿Ï… Safari');
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = 'GPS: ÎœÎ· Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿';
                    break;
                case error.TIMEOUT:
                    message = 'GPS: Timeout';
                    break;
            }
            
            this.updateStatus('gps', false, message);
        }

        initOrientation() {
            // Request permission for iOS 13+
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            this.setupOrientationListeners();
                        } else {
                            this.updateStatus('orientation', false, 'Î ÏÎ¿ÏƒÎ±Î½Î±Ï„Î¿Î»Î¹ÏƒÎ¼ÏŒÏ‚: Î‘Ï€Î¿ÏÏÎ¯Ï†Î¸Î·ÎºÎµ');
                            this.showError('Î Î±ÏÎ±ÎºÎ±Î»Ï ÎµÏ€Î¹Ï„ÏÎ­ÏˆÏ„Îµ Ï„Î·Î½ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î¿Î½ Ï€ÏÎ¿ÏƒÎ±Î½Î±Ï„Î¿Î»Î¹ÏƒÎ¼ÏŒ ÏƒÏ…ÏƒÎºÎµÏ…Î®Ï‚');
                        }
                    })
                    .catch(error => {
                        console.error('Orientation permission error:', error);
                        this.updateStatus('orientation', false, 'Î ÏÎ¿ÏƒÎ±Î½Î±Ï„Î¿Î»Î¹ÏƒÎ¼ÏŒÏ‚: Î£Ï†Î¬Î»Î¼Î±');
                    });
            } else {
                // Android or older iOS
                this.setupOrientationListeners();
            }
        }

        setupOrientationListeners() {
            let hasReceived = false;

            const handleOrientation = (event) => {
                if (!hasReceived) {
                    hasReceived = true;
                    this.updateStatus('orientation', true, 'Î ÏÎ¿ÏƒÎ±Î½Î±Ï„Î¿Î»Î¹ÏƒÎ¼ÏŒÏ‚: Î•Î½ÎµÏÎ³ÏŒÏ‚');
                }

                if (this.debugMode) {
                    const alpha = event.alpha || 0;
                    const beta = event.beta || 0;
                    const gamma = event.gamma || 0;
                    document.getElementById('debug-heading').textContent = 
                        `Î±:${alpha.toFixed(1)}Â° Î²:${beta.toFixed(1)}Â° Î³:${gamma.toFixed(1)}Â°`;
                }
            };

            // Listen to orientation events
            window.addEventListener('deviceorientationabsolute', handleOrientation, true);
            window.addEventListener('deviceorientation', handleOrientation, true);

            // Fallback timeout
            setTimeout(() => {
                if (!hasReceived) {
                    this.updateStatus('orientation', false, 'Î ÏÎ¿ÏƒÎ±Î½Î±Ï„Î¿Î»Î¹ÏƒÎ¼ÏŒÏ‚: Timeout');
                }
            }, 5000);

            console.log('ğŸ§­ Orientation listeners setup');
        }

        async loadKMLFiles(files) {
            this.showLoading(true);
            let totalFeatures = 0;

            try {
                for (const file of files) {
                    console.log(`ğŸ“ Processing ${file.name}`);
                    const features = await this.parseKML(file);
                    
                    console.log(`ğŸ“„ Parsed features:`, features);
                    
                    // Create AR objects for each feature
                    let createdObjects = 0;
                    features.forEach((feature, index) => {
                        console.log(`ğŸ¯ Creating AR object ${index + 1}/${features.length}:`, feature);
                        const success = this.createARObject(feature);
                        if (success) createdObjects++;
                    });
                    
                    console.log(`âœ… Created ${createdObjects}/${features.length} AR objects`);
                    
                    this.features.push(...features);
                    totalFeatures += features.length;
                }

                this.updateStatus('features', totalFeatures > 0, `Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î±: ${totalFeatures}`);
                
                if (this.debugMode) {
                    document.getElementById('debug-features').textContent = totalFeatures;
                    document.getElementById('debug-objects').textContent = this.container.children.length;
                    
                    // Add detailed position info to debug
                    this.updateDebugInfo();
                }

                if (totalFeatures > 0) {
                    const objectsCount = this.container.children.length;
                    this.showInfo(`âœ… Î¦Î¿ÏÏ„ÏÎ¸Î·ÎºÎ±Î½ ${totalFeatures} ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î±! Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î®Î¸Î·ÎºÎ±Î½ ${objectsCount} AR objects. 
```

ğŸ” Î•Î»Î­Î³Î¾Ï„Îµ Ï„Î¿ Debug panel Î³Î¹Î± Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚ Î¸Î­ÏƒÎ·Ï‚.
ğŸ“± ÎšÎ¹Î½Î·Î¸ÎµÎ¯Ï„Îµ Î±ÏÎ³Î¬ ÎºÎ±Î¹ ÏƒÏ„ÏÎ­ÏˆÏ„Îµ Ï„Î·Î½ ÎºÎ¬Î¼ÎµÏÎ± Î³ÏÏÏ‰ ÏƒÎ±Ï‚.
ğŸ“ Î¤Î± objects ÎµÎ¯Î½Î±Î¹ Î¼ÎµÎ³Î¬Î»Î± ÎºÎ±Î¹ Ï†Ï‰Ï„ÎµÎ¹Î½Î¬ Î³Î¹Î± ÎºÎ±Î»ÏÏ„ÎµÏÎ· Î¿ÏÎ±Ï„ÏŒÏ„Î·Ï„Î±.
âš ï¸ Î‘Î½ Î´ÎµÎ½ Ï„Î± Î²Î»Î­Ï€ÎµÏ„Îµ, ÎµÎ»Î­Î³Î¾Ï„Îµ Î±Î½ Î²ÏÎ¯ÏƒÎºÎµÏƒÏ„Îµ ÎºÎ¿Î½Ï„Î¬ ÏƒÏ„Î·Î½ Ï€ÎµÏÎ¹Î¿Ï‡Î® Ï„Ï‰Î½ Î´ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½.`);

```
                    // Force update all AR objects
                    this.forceUpdateARObjects();
                } else {
                    this.showError('Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Î­Î³ÎºÏ…ÏÎ± Î³ÎµÏ‰Î³ÏÎ±Ï†Î¹ÎºÎ¬ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± ÏƒÏ„Î± Î±ÏÏ‡ÎµÎ¯Î± KML');
                }

            } catch (error) {
                console.error('âŒ Error loading KML:', error);
                this.showError(`Î£Ï†Î¬Î»Î¼Î± Ï†ÏŒÏÏ„Ï‰ÏƒÎ·Ï‚ KML: ${error.message}`);
            } finally {
                this.showLoading(false);
            }
        }

        parseKML(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        const kmlString = e.target.result;
                        const parser = new DOMParser();
                        const kmlDoc = parser.parseFromString(kmlString, 'text/xml');
                        
                        // Check for parsing errors
                        const parseError = kmlDoc.querySelector('parsererror');
                        if (parseError) {
                            throw new Error('ÎœÎ· Î­Î³ÎºÏ…ÏÎ¿ KML Î±ÏÏ‡ÎµÎ¯Î¿');
                        }

                        // Use toGeoJSON library if available
                        let geoJson;
                        if (typeof toGeoJSON !== 'undefined' && toGeoJSON.kml) {
                            geoJson = toGeoJSON.kml(kmlDoc);
                        } else {
                            // Manual parsing fallback
                            geoJson = this.manualKMLParse(kmlDoc);
                        }

                        if (!geoJson || !geoJson.features || geoJson.features.length === 0) {
                            throw new Error('Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Î³ÎµÏ‰Î³ÏÎ±Ï†Î¹ÎºÎ¬ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± ÏƒÏ„Î¿ Î±ÏÏ‡ÎµÎ¯Î¿');
                        }

                        console.log(`ğŸ“„ Parsed ${geoJson.features.length} features from ${file.name}`);
                        resolve(geoJson.features);

                    } catch (error) {
                        reject(new Error(`Î£Ï†Î¬Î»Î¼Î± Î±Î½Î¬Î»Ï…ÏƒÎ·Ï‚ Î±ÏÏ‡ÎµÎ¯Î¿Ï… ${file.name}: ${error.message}`));
                    }
                };
                
                reader.onerror = () => reject(new Error('Î£Ï†Î¬Î»Î¼Î± Î±Î½Î¬Î³Î½Ï‰ÏƒÎ·Ï‚ Î±ÏÏ‡ÎµÎ¯Î¿Ï…'));
                reader.readAsText(file);
            });
        }

        manualKMLParse(kmlDoc) {
            const features = [];
            const placemarks = kmlDoc.querySelectorAll('Placemark');
            
            placemarks.forEach((placemark, index) => {
                const name = placemark.querySelector('name')?.textContent || `Feature ${index + 1}`;
                const description = placemark.querySelector('description')?.textContent || '';
                
                // Parse coordinates
                const coordsElements = placemark.querySelectorAll('coordinates');
                
                coordsElements.forEach(coordsEl => {
                    const coordsText = coordsEl.textContent.trim();
                    const coordinates = this.parseCoordinatesString(coordsText);
                    
                    if (coordinates.length > 0) {
                        let geometry;
                        
                        if (coordinates.length === 1) {
                            // Point
                            geometry = {
                                type: 'Point',
                                coordinates: coordinates[0]
                            };
                        } else if (coordinates.length >= 2) {
                            // Line or Polygon
                            const isPolygon = placemark.querySelector('Polygon') !== null;
                            geometry = {
                                type: isPolygon ? 'Polygon' : 'LineString',
                                coordinates: isPolygon ? [coordinates] : coordinates
                            };
                        }
                        
                        if (geometry) {
                            features.push({
                                type: 'Feature',
                                properties: { name, description },
                                geometry: geometry
                            });
                        }
                    }
                });
            });
            
            return { type: 'FeatureCollection', features: features };
        }

        parseCoordinatesString(coordsText) {
            const coordinates = [];
            const pairs = coordsText.split(/\s+/);
            
            pairs.forEach(pair => {
                const parts = pair.split(',');
                if (parts.length >= 2) {
                    const lng = parseFloat(parts[0]);
                    const lat = parseFloat(parts[1]);
                    const alt = parts[2] ? parseFloat(parts[2]) : 0;
                    
                    if (!isNaN(lng) && !isNaN(lat)) {
                        coordinates.push([lng, lat, alt]);
                    }
                }
            });
            
            return coordinates;
        }

        createARObject(feature) {
            if (!feature.geometry || !feature.geometry.coordinates) {
                console.warn('âŒ Feature missing geometry:', feature);
                return false;
            }

            console.log(`ğŸ¯ Creating AR object for feature:`, feature);

            const entity = document.createElement('a-entity');
            entity.setAttribute('class', 'ar-object');
            
            // Get position for the object
            let position;
            try {
                switch (feature.geometry.type) {
                    case 'Point':
                        position = {
                            lat: feature.geometry.coordinates[1],
                            lng: feature.geometry.coordinates[0],
                            alt: feature.geometry.coordinates[2] || 0
                        };
                        break;
                    case 'LineString':
                        // Use midpoint
                        const coords = feature.geometry.coordinates;
                        const midIndex = Math.floor(coords.length / 2);
                        position = {
                            lat: coords[midIndex][1],
                            lng: coords[midIndex][0],
                            alt: coords[midIndex][2] || 0
                        };
                        break;
                    case 'Polygon':
                        // Calculate centroid for polygon positioning
                        const ring = feature.geometry.coordinates[0];
                        let latSum = 0, lngSum = 0, altSum = 0;
                        const validCoords = ring.slice(0, -1); // Remove duplicate last coordinate
                        validCoords.forEach(coord => {
                            lngSum += coord[0];
                            latSum += coord[1];
                            altSum += coord[2] || 0;
                        });
                        position = {
                            lat: latSum / validCoords.length,
                            lng: lngSum / validCoords.length,
                            alt: 0 // Force ground level for polygons
                        };
                        break;
                    default:
                        console.warn('âŒ Unsupported geometry type:', feature.geometry.type);
                        return false;
                }
            } catch (error) {
                console.error('âŒ Error calculating position for feature:', error);
                return false;
            }

            if (!position || isNaN(position.lat) || isNaN(position.lng)) {
                console.error('âŒ Invalid position calculated:', position);
                return false;
            }

            console.log(`ğŸ“ AR object position:`, position);

            // Validate coordinates are reasonable
            if (Math.abs(position.lat) > 90 || Math.abs(position.lng) > 180) {
                console.error('âŒ Invalid coordinates out of range:', position);
                return false;
            }

            // Set GPS position with explicit values
            const gpsAttrs = `latitude: ${position.lat.toFixed(6)}; longitude: ${position.lng.toFixed(6)}; altitude: ${position.alt || 0}`;
            console.log(`ğŸŒ Setting GPS attributes: ${gpsAttrs}`);
            entity.setAttribute('gps-new-entity-place', gpsAttrs);

            // Create visual representation
            try {
                this.createVisualForFeature(entity, feature);
            } catch (error) {
                console.error('âŒ Error creating visual for feature:', error);
                return false;
            }

            // Add to scene
            try {
                this.container.appendChild(entity);
                
                // Calculate distance from user if available
                let distance = 'Unknown';
                let distanceInfo = '';
                if (this.userPosition) {
                    const distanceM = this.calculateDistance(
                        this.userPosition.latitude, this.userPosition.longitude,
                        position.lat, position.lng
                    );
                    distance = `${distanceM}m`;
                    distanceInfo = `Distance: ${distanceM}m, User: ${this.userPosition.latitude.toFixed(6)}, ${this.userPosition.longitude.toFixed(6)}, Object: ${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`;
                    
                    // Log detailed distance info for debugging
                    console.log(`ğŸ“ ${distanceInfo}`);
                    
                    // If object is very far, warn user
                    if (distanceM > 10000) {
                        console.warn(`âš ï¸ AR object is very far away (${distanceM}m). It might not be visible.`);
                    }
                }
                
                console.log(`âœ… AR object created successfully for ${feature.properties.name || 'Unnamed'} at ${position.lat.toFixed(6)}, ${position.lng.toFixed(6)} (${distance} away)`);
                
                // Also log in debug panel if enabled
                if (this.debugMode) {
                    console.log(`ğŸ” Debug: ${distanceInfo}`);
                }
                
                return true;
            } catch (error) {
                console.error('âŒ Error adding AR object to scene:', error);
                return false;
            }
        }

        calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371e3; // Earth's radius in meters
            const Ï†1 = lat1 * Math.PI/180;
            const Ï†2 = lat2 * Math.PI/180;
            const Î”Ï† = (lat2-lat1) * Math.PI/180;
            const Î”Î» = (lng2-lng1) * Math.PI/180;

            const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                    Math.cos(Ï†1) * Math.cos(Ï†2) *
                    Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return Math.round(R * c);
        }

        createVisualForFeature(entity, feature) {
            const type = feature.geometry.type;
            const name = feature.properties.name || 'Unnamed';
            
            console.log(`ğŸ¨ Creating visual for ${type}: ${name}`);
            
            // Create geometry based on type - make them ground-level and realistic
            switch (type) {
                case 'Point':
                    // Vertical marker post for points
                    entity.setAttribute('geometry', 'primitive: cylinder; radius: 1; height: 10');
                    entity.setAttribute('material', 'color: #ff4444; emissive: #ff2222; emissiveIntensity: 0.3');
                    entity.setAttribute('position', '0 5 0'); // Half height above ground
                    break;
                case 'LineString':
                    // Line marker posts
                    entity.setAttribute('geometry', 'primitive: cylinder; radius: 0.5; height: 6');
                    entity.setAttribute('material', 'color: #4444ff; emissive: #2222ff; emissiveIntensity: 0.3');
                    entity.setAttribute('position', '0 3 0');
                    break;
                case 'Polygon':
                    // Ground-level polygon outline - create wireframe boundary
                    this.createPolygonOutline(entity, feature);
                    return; // Skip the rest for polygons as we handle them specially
            }

            // Add text label - smaller and at reasonable height
            const text = document.createElement('a-text');
            text.setAttribute('value', name);
            text.setAttribute('position', '0 8 0'); // Just above the marker
            text.setAttribute('align', 'center');
            text.setAttribute('color', '#ffffff');
            text.setAttribute('scale', '15 15 15');
            text.setAttribute('material', 'color: #ffffff; shader: msdf');
            text.setAttribute('look-at', '[gps-new-camera]');
            
            entity.appendChild(text);
            
            console.log(`âœ¨ Visual created for ${name}`);
        }

        createPolygonOutline(entity, feature) {
            const name = feature.properties.name || 'Unnamed';
            console.log(`ğŸ—ï¸ Creating polygon outline for: ${name}`);
            
            // Get the outer ring coordinates
            const coordinates = feature.geometry.coordinates[0];
            
            // Create corner markers at each vertex
            coordinates.forEach((coord, index) => {
                if (index === coordinates.length - 1) return; // Skip last point (same as first)
                
                const cornerMarker = document.createElement('a-entity');
                cornerMarker.setAttribute('geometry', 'primitive: cylinder; radius: 0.8; height: 4');
                cornerMarker.setAttribute('material', 'color: #00ff00; emissive: #00cc00; emissiveIntensity: 0.5');
                cornerMarker.setAttribute('position', '0 2 0');
                
                // Calculate relative position from centroid
                const centroid = this.calculatePolygonCentroid(coordinates);
                const relativePos = this.coordsToRelativePosition(coord, centroid);
                
                cornerMarker.setAttribute('position', `${relativePos.x} 2 ${relativePos.z}`);
                entity.appendChild(cornerMarker);
                
                // Add corner number label
                const cornerText = document.createElement('a-text');
                cornerText.setAttribute('value', `${index + 1}`);
                cornerText.setAttribute('position', `0 3 0`);
                cornerText.setAttribute('align', 'center');
                cornerText.setAttribute('color', '#ffffff');
                cornerText.setAttribute('scale', '8 8 8');
                cornerText.setAttribute('look-at', '[gps-new-camera]');
                cornerMarker.appendChild(cornerText);
            });
            
            // Create a ground plane outline
            const outline = document.createElement('a-entity');
            outline.setAttribute('geometry', 'primitive: plane; width: 1; height: 1');
            outline.setAttribute('material', 'color: #44ff44; opacity: 0.3; transparent: true; side: double');
            outline.setAttribute('rotation', '-90 0 0');
            outline.setAttribute('position', '0 0.1 0'); // Slightly above ground
            
            // Scale the plane to approximate polygon size
            const bounds = this.calculatePolygonBounds(coordinates);
            const width = Math.abs(bounds.maxX - bounds.minX) * 111000; // Convert degrees to meters approximately
            const height = Math.abs(bounds.maxY - bounds.minY) * 111000;
            outline.setAttribute('geometry', `primitive: plane; width: ${width}; height: ${height}`);
            
            entity.appendChild(outline);
            
            // Add property name label at center
            const centerText = document.createElement('a-text');
            centerText.setAttribute('value', name);
            centerText.setAttribute('position', '0 6 0');
            centerText.setAttribute('align', 'center');
            centerText.setAttribute('color', '#ffffff');
            centerText.setAttribute('scale', '20 20 20');
            centerText.setAttribute('material', 'color: #ffffff; shader: msdf');
            centerText.setAttribute('look-at', '[gps-new-camera]');
            entity.appendChild(centerText);
            
            console.log(`âœ… Polygon outline created with ${coordinates.length - 1} corner markers`);
        }

        calculatePolygonCentroid(coordinates) {
            let latSum = 0, lngSum = 0;
            const validCoords = coordinates.slice(0, -1); // Remove duplicate last point
            
            validCoords.forEach(coord => {
                lngSum += coord[0];
                latSum += coord[1];
            });
            
            return {
                lat: latSum / validCoords.length,
                lng: lngSum / validCoords.length
            };
        }
        
        calculatePolygonBounds(coordinates) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            coordinates.forEach(coord => {
                minX = Math.min(minX, coord[0]);
                maxX = Math.max(maxX, coord[0]);
                minY = Math.min(minY, coord[1]);
                maxY = Math.max(maxY, coord[1]);
            });
            
            return { minX, maxX, minY, maxY };
        }
        
        coordsToRelativePosition(coord, centroid) {
            // Convert lat/lng difference to approximate meter offsets
            const latDiff = coord[1] - centroid.lat;
            const lngDiff = coord[0] - centroid.lng;
            
            // Rough conversion: 1 degree â‰ˆ 111,000 meters
            const x = lngDiff * 111000 * Math.cos(centroid.lat * Math.PI / 180);
            const z = -latDiff * 111000; // Negative because Z+ is south in AR.js
            
            return { x, z };
        }

        forceUpdateARObjects() {
            console.log('ğŸ”„ Force updating AR objects...');
            
            // Ensure all AR objects are visible and properly positioned
            const children = Array.from(this.container.children);
            children.forEach((child, index) => {
                console.log(`ğŸ”„ Updating AR object ${index + 1}/${children.length}`);
                
                // Force visibility
                child.setAttribute('visible', 'true');
                
                // Trigger a position update if GPS component exists
                if (child.components && child.components['gps-new-entity-place']) {
                    try {
                        child.components['gps-new-entity-place'].tick();
                    } catch (e) {
                        console.log('Could not force tick GPS component:', e.message);
                    }
                }
                
                // Log current transform
                const position = child.getAttribute('position');
                const gpsPos = child.getAttribute('gps-new-entity-place');
                console.log(`ğŸ“ AR Object ${index}: GPS=${JSON.stringify(gpsPos)}, Position=${JSON.stringify(position)}`);
            });
            
            console.log(`âœ… Force update complete for ${children.length} AR objects`);
        }

        updateDebugInfo() {
            if (!this.debugMode) return;
            
            // Add more detailed debugging information
            const debugPanel = document.getElementById('debug-panel');
            
            // Remove old extra debug info
            const extraDebugElements = debugPanel.querySelectorAll('.extra-debug');
            extraDebugElements.forEach(el => el.remove());
            
            // Add current AR objects info
            if (this.container.children.length > 0) {
                Array.from(this.container.children).forEach((child, index) => {
                    const gpsAttr = child.getAttribute('gps-new-entity-place');
                    const position = child.getAttribute('position');
                    
                    const debugDiv = document.createElement('div');
                    debugDiv.className = 'extra-debug';
                    debugDiv.textContent = `AR${index}: GPS(${gpsAttr ? gpsAttr.latitude + ',' + gpsAttr.longitude : 'none'}) POS(${position ? position.x + ',' + position.y + ',' + position.z : 'none'})`;
                    debugPanel.appendChild(debugDiv);
                });
            }
        }

        clearAll() {
            // Remove all AR objects
            while (this.container.firstChild) {
                this.container.removeChild(this.container.firstChild);
            }
            
            this.features = [];
            this.updateStatus('features', false, 'Î£Ï„Î¿Î¹Ï‡ÎµÎ¯Î±: 0');
            
            if (this.debugMode) {
                document.getElementById('debug-features').textContent = '0';
                document.getElementById('debug-objects').textContent = '0';
                this.updateDebugInfo();
            }
            
            this.showInfo('ğŸ—‘ï¸ ÎŒÎ»Î± Ï„Î± AR ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± ÎºÎ±Î¸Î±ÏÎ¯ÏƒÏ„Î·ÎºÎ±Î½');
            
            // Clear file input
            document.getElementById('kml-input').value = '';
        }

        updateStatus(type, active, text) {
            const dot = document.getElementById(`${type}-dot`);
            const textEl = document.getElementById(`${type}-text`);
            
            if (dot && textEl) {
                if (active) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
                textEl.textContent = text;
            }
        }

        showInfo(message) {
            const info = document.getElementById('info');
            info.innerHTML = message;
            info.classList.add('show');
            
            setTimeout(() => {
                info.classList.remove('show');
            }, 10000); // Increased timeout for longer messages
        }

        showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        showError(message) {
            const dialog = document.getElementById('error-dialog');
            document.getElementById('error-text').textContent = message;
            dialog.style.display = 'block';
        }
    }

    // Global functions
    function hideError() {
        document.getElementById('error-dialog').style.display = 'none';
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
        // Check for HTTPS
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
            document.getElementById('error-text').textContent = 
                'Î— ÎµÏ†Î±ÏÎ¼Î¿Î³Î® Î±Ï€Î±Î¹Ï„ÎµÎ¯ HTTPS Î³Î¹Î± Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î·Î½ ÎºÎ¬Î¼ÎµÏÎ± ÎºÎ±Î¹ GPS. Î Î±ÏÎ±ÎºÎ±Î»Ï Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ https://olympos2025.github.io/DotsikoAR-WebAR/';
            document.getElementById('error-dialog').style.display = 'block';
            return;
        }

        // Initialize MapLens
        window.mapLensAR = new MapLensAR();
    });

    // Handle device orientation permission on user interaction
    let permissionRequested = false;
    function requestPermissions() {
        if (permissionRequested) return;
        permissionRequested = true;
        
        if (typeof DeviceOrientationEvent !== 'undefined' && 
            typeof DeviceOrientationEvent.requestPermission === 'function') {
            
            DeviceOrientationEvent.requestPermission().catch(console.error);
        }
    }

    document.addEventListener('click', requestPermissions, { once: true });
    document.addEventListener('touchstart', requestPermissions, { once: true });
</script>
```

</body>
</html>