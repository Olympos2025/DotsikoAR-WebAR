<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="utf-8">
    <title>MapLens</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- A-Frame & AR.js -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <style>
        :root {
            /* Σύγχρονη παλέτα χρωμάτων 2025 */
            --primary: #4361EE;      /* Ζωντανό μπλε */
            --secondary: #4CC9F0;    /* Φωτεινό κυανό */
            --accent: #F72585;       /* Ζωντανό ροζ */
            --light: #F8F9FA;        /* Ανοιχτό γκρι-λευκό */
            --dark: #212529;         /* Σκούρο γκρι */
            --success: #2ECC71;      /* Πράσινο επιτυχίας */
            --warning: #F1C40F;      /* Κίτρινο προειδοποίησης */
            --error: #E74C3C;        /* Κόκκινο σφάλματος */
            
            /* Παράμετροι διεπαφής */
            --frame-thickness: 30px; /* Πάχος εξωτερικού πλαισίου */
            --tick-length: 5px;      /* Μήκος γραμμών που προεξέχουν */
            --tick-spacing: 40px;    /* Απόσταση μεταξύ γραμμών συντεταγμένων */
            --sidebar-width: 340px;  /* Πλάτος πλευρικής στήλης */
            --border-radius: 12px;   /* Στρογγυλεμένες γωνίες */
        }
        
        body {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        /* Εξωτερικό πλαίσιο με γραμμές συντεταγμένων */
        .frame-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            pointer-events: none;
        }
        
        .frame-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: var(--frame-thickness) solid rgba(67, 97, 238, 0.3);
            box-sizing: border-box;
        }
        
        /* Tick marks που προεξέχουν */
        .tick-marks {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .tick-mark {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.7);
            z-index: 10000;
        }
        
        .tick-mark.horizontal {
            width: var(--tick-spacing);
            height: 1px;
        }
        
        .tick-mark.vertical {
            width: 1px;
            height: var(--tick-spacing);
        }
        
        /* Κουμπί εμφάνισης μενού */
        #menu-toggle {
            position: fixed;
            top: calc(var(--frame-thickness) + 15px);
            left: calc(var(--frame-thickness) + 15px);
            z-index: 10000;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border: none;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(67, 97, 238, 0.3);
        }
        
        #menu-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(67, 97, 238, 0.4);
        }
        
        /* Πλευρική στήλη */
        #sidebar {
            position: fixed;
            top: var(--frame-thickness);
            left: var(--frame-thickness);
            bottom: var(--frame-thickness);
            width: var(--sidebar-width);
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 9990;
            transform: translateX(-100%);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            padding-top: 70px;
            box-shadow: 5px 0 30px rgba(0, 0, 0, 0.1);
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }
        
        #sidebar.open {
            transform: translateX(0);
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }
        
        .panel:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
        }
        
        /* Logo MapLens */
        .app-logo {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .logo-text {
            font-size: 2.5em;
            font-weight: bold;
            font-style: italic;
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);
            display: inline-block;
            position: relative;
        }
        
        .logo-text::before {
            content: "MapLens";
            position: absolute;
            top: 2px;
            left: 2px;
            opacity: 0.1;
            -webkit-text-fill-color: var(--primary);
            z-index: -1;
        }
        
        .logo-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            border-radius: 50%;
            margin-right: 10px;
            vertical-align: middle;
            box-shadow: 0 3px 10px rgba(67, 97, 238, 0.3);
        }
        
        .logo-icon svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        
        #status {
            color: var(--dark);
            font-size: 1em;
            font-weight: 600;
            text-align: center;
            margin-top: 10px;
        }
        
        #accuracy {
            color: var(--dark);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            margin: 10px auto;
            display: block;
            width: fit-content;
            font-weight: 500;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }
        
        #datetime {
            color: var(--dark);
            opacity: 0.7;
            text-align: center;
            margin-top: 5px;
            font-size: 0.9em;
            letter-spacing: 0.5px;
        }
        
        .btn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            margin: 8px 0;
            transition: all 0.3s ease;
            display: block;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(67, 97, 238, 0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(67, 97, 238, 0.3);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        #file-input {
            display: none;
        }
        
        #error-message {
            color: var(--error);
            background: rgba(231, 76, 60, 0.1);
            border-radius: var(--border-radius);
            padding: 12px 15px;
            margin-top: 10px;
            font-size: 0.9em;
            display: none;
        }

        /* Επιλογέας γλώσσας */
        #language-selector {
            position: fixed;
            top: calc(var(--frame-thickness) + 15px);
            right: calc(var(--frame-thickness) + 15px);
            z-index: 10000;
            display: flex;
            gap: 5px;
        }

        #language-selector button {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            color: var(--dark);
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        #language-selector button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        #language-selector button.active {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(67, 97, 238, 0.3);
        }

        /* Πληροφορίες δημιουργού */
        #copyright {
            position: fixed;
            bottom: calc(var(--frame-thickness) + 10px);
            right: calc(var(--frame-thickness) + 15px);
            font-size: 0.8em;
            color: var(--dark);
            opacity: 0.7;
            text-align: right;
            z-index: 10000;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 8px 15px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        #copyright:hover {
            opacity: 1;
        }

        #copyright a {
            color: var(--primary);
            text-decoration: none;
            transition: color 0.2s;
        }

        #copyright a:hover {
            color: var(--accent);
        }

        /* Input styling */
        input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 10px;
            border: 1px solid rgba(67, 97, 238, 0.2);
            border-radius: 30px;
            transition: all 0.3s ease;
            box-sizing: border-box;
            font-size: 0.9em;
        }

        input[type="text"]:focus {
            border-color: var(--secondary);
            outline: none;
            box-shadow: 0 0 0 3px rgba(76, 201, 240, 0.2);
        }

        /* Status colors */
        .status-good {
            background-color: rgba(46, 204, 113, 0.2);
            color: var(--dark);
        }

        .status-medium {
            background-color: rgba(241, 196, 15, 0.2);
            color: var(--dark);
        }

        .status-bad {
            background-color: rgba(231, 76, 60, 0.2);
            color: var(--dark);
        }

        .divider {
            color: var(--dark);
            opacity: 0.5;
            margin: 10px 0;
            text-align: center;
            font-size: 0.9em;
        }
        
        /* Προσαρμογή για μικρότερες οθόνες */
        @media (max-width: 768px) {
            :root {
                --frame-thickness: 20px;
                --sidebar-width: 280px;
            }
            
            .logo-text {
                font-size: 2em;
            }
            
            .btn {
                padding: 10px 15px;
            }
        }
    </style>
</head>
<body>
    <!-- Εξωτερικό πλαίσιο με tick marks -->
    <div class="frame-container">
        <div class="frame-border"></div>
        <div class="tick-marks" id="tick-marks"></div>
    </div>
    
    <!-- Κουμπί εμφάνισης μενού -->
    <button id="menu-toggle">☰</button>
    
    <!-- Επιλογέας γλώσσας -->
    <div id="language-selector">
        <button id="lang-el" class="active">EL</button>
        <button id="lang-en">EN</button>
    </div>

    <!-- Πληροφορίες δημιουργού -->
    <div id="copyright">
        © 2025 Thomas G. Lagkas | <a href="mailto:Thomas.lagkas@outlook.com">Thomas.lagkas@outlook.com</a>
    </div>
    
    <!-- Πλευρική στήλη με όλα τα πλαίσια -->
    <div id="sidebar">
        <div class="panel">
            <div class="app-logo">
                <span class="logo-icon">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                    </svg>
                </span>
                <span class="logo-text">MapLens</span>
            </div>
            <div id="status">⌛ Αναμονή GPS...</div>
            <span id="accuracy">Ακρίβεια GPS: Αναμονή...</span>
            <div id="datetime"></div>
        </div>
        
        <div class="panel">
            <input type="file" id="file-input" accept=".kml">
            <button id="upload-btn" class="btn" data-el="Φόρτωση KML" data-en="Load KML">Φόρτωση KML</button>
            <div class="divider" data-el="ή" data-en="or">ή</div>
            <input type="text" id="url-input" placeholder="URL του KML αρχείου" data-el-placeholder="URL του KML αρχείου" data-en-placeholder="KML file URL">
            <button id="load-url-btn" class="btn" data-el="Φόρτωση από URL" data-en="Load from URL">Φόρτωση από URL</button>
        </div>
        
        <div class="panel">
            <button id="toggle-btn" class="btn" data-el="Εμφάνιση/Απόκρυψη AR" data-en="Show/Hide AR">Εμφάνιση/Απόκρυψη AR</button>
            <button id="reset-btn" class="btn" data-el="Επαναφορά" data-en="Reset">Επαναφορά</button>
        </div>
        
        <div id="error-message" class="panel"></div>
    </div>

    <!-- A-Frame Scene -->
    <a-scene 
        vr-mode-ui="enabled: false"
        arjs="sourceType: webcam; debugUIEnabled: false; sourceWidth: 1280; sourceHeight: 960;"
        renderer="logarithmicDepthBuffer: true; precision: medium;"
        embedded>
        <a-camera gps-camera rotation-reader></a-camera>
        <a-entity id="kml-container"></a-entity>
    </a-scene>

    <script>
        // Global variables
        let arVisible = true;
        let currentAccuracy = null;
        let userPosition = null;
        let currentLanguage = 'el';
        
        // DOM Elements
        const menuToggle = document.getElementById('menu-toggle');
        const sidebar = document.getElementById('sidebar');
        const fileInput = document.getElementById('file-input');
        const uploadBtn = document.getElementById('upload-btn');
        const urlInput = document.getElementById('url-input');
        const loadUrlBtn = document.getElementById('load-url-btn');
        const toggleBtn = document.getElementById('toggle-btn');
        const resetBtn = document.getElementById('reset-btn');
        const statusEl = document.getElementById('status');
        const accuracyEl = document.getElementById('accuracy');
        const datetimeEl = document.getElementById('datetime');
        const errorMessageEl = document.getElementById('error-message');
        const kmlContainer = document.getElementById('kml-container');
        const langEl = document.getElementById('lang-el');
        const langEn = document.getElementById('lang-en');
        const tickMarksContainer = document.getElementById('tick-marks');

        // Δημιουργία των tick marks
        function createTickMarks() {
            // Καθαρισμός προηγούμενων tick marks
            tickMarksContainer.innerHTML = '';
            
            // Υπολογισμός αριθμού tick marks
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const frameThickness = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--frame-thickness'));
            const tickSpacing = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tick-spacing'));
            const tickLength = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tick-length'));
            
            // Δημιουργία οριζόντιων tick marks (πάνω)
            for (let i = frameThickness; i < windowWidth - frameThickness; i += tickSpacing) {
                const tick = document.createElement('div');
                tick.className = 'tick-mark horizontal';
                tick.style.top = `${frameThickness}px`;
                tick.style.left = `${i}px`;
                tick.style.height = `${tickLength}px`;
                tickMarksContainer.appendChild(tick);
            }
            
            // Δημιουργία οριζόντιων tick marks (κάτω)
            for (let i = frameThickness; i < windowWidth - frameThickness; i += tickSpacing) {
                const tick = document.createElement('div');
                tick.className = 'tick-mark horizontal';
                tick.style.bottom = `${frameThickness}px`;
                tick.style.left = `${i}px`;
                tick.style.height = `${tickLength}px`;
                tickMarksContainer.appendChild(tick);
            }
            
            // Δημιουργία κάθετων tick marks (αριστερά)
            for (let i = frameThickness; i < windowHeight - frameThickness; i += tickSpacing) {
                const tick = document.createElement('div');
                tick.className = 'tick-mark vertical';
                tick.style.left = `${frameThickness}px`;
                tick.style.top = `${i}px`;
                tick.style.width = `${tickLength}px`;
                tickMarksContainer.appendChild(tick);
            }
            
            // Δημιουργία κάθετων tick marks (δεξιά)
            for (let i = frameThickness; i < windowHeight - frameThickness; i += tickSpacing) {
                const tick = document.createElement('div');
                tick.className = 'tick-mark vertical';
                tick.style.right = `${frameThickness}px`;
                tick.style.top = `${i}px`;
                tick.style.width = `${tickLength}px`;
                tickMarksContainer.appendChild(tick);
            }
        }

        // Κείμενα μεταφράσεων
        const translations = {
            el: {
                waiting: "⌛ Αναμονή GPS...",
                active: "✅ GPS ενεργό",
                loading: "⏳ Φόρτωση KML...",
                loaded: "✅ KML φορτώθηκε!",
                error: "❌ Σφάλμα!",
                reset: "AR επαναφέρθηκε",
                accuracy: "Ακρίβεια GPS: ",
                notAvailable: "Ακρίβεια GPS: Μη διαθέσιμη",
                urlRequired: "Παρακαλώ εισάγετε ένα URL!",
                noPolygons: "Δεν βρέθηκαν πολύγωνα/γραμμές/σημεία στο KML!",
                invalidXml: "Μη έγκυρο XML!",
                readError: "Σφάλμα ανάγνωσης αρχείου!",
                parseError: "Σφάλμα ανάλυσης KML: ",
                downloadError: "Σφάλμα λήψης KML: ",
                meters: "m",
                hideAR: "Απόκρυψη AR",
                showAR: "Εμφάνιση AR"
            },
            en: {
                waiting: "⌛ Waiting for GPS...",
                active: "✅ GPS active",
                loading: "⏳ Loading KML...",
                loaded: "✅ KML loaded!",
                error: "❌ Error!",
                reset: "AR reset",
                accuracy: "GPS accuracy: ",
                notAvailable: "GPS accuracy: Not available",
                urlRequired: "Please enter a URL!",
                noPolygons: "No polygons/lines/points found in the KML!",
                invalidXml: "Invalid XML!",
                readError: "Error reading file!",
                parseError: "Error parsing KML: ",
                downloadError: "Error downloading KML: ",
                meters: "m",
                hideAR: "Hide AR",
                showAR: "Show AR"
            }
        };

        // Αρχικοποίηση
        window.addEventListener('DOMContentLoaded', () => {
            createTickMarks();
            updateDateTime();
        });
        
        // Προσαρμογή σε αλλαγή μεγέθους παραθύρου
        window.addEventListener('resize', createTickMarks);

        // Toggle sidebar
        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            menuToggle.textContent = sidebar.classList.contains('open') ? '✕' : '☰';
        });

        // Date & time
        function updateDateTime() {
            const now = new Date();
            datetimeEl.textContent = now.toLocaleString(currentLanguage === 'el' ? 'el-GR' : 'en-US');
        }
        setInterval(updateDateTime, 1000);

        // Event listeners
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileUpload);
        loadUrlBtn.addEventListener('click', handleUrlLoad);
        toggleBtn.addEventListener('click', toggleARVisibility);
        resetBtn.addEventListener('click', resetAR);
        
        // Language switchers
        langEl.addEventListener('click', () => setLanguage('el'));
        langEn.addEventListener('click', () => setLanguage('en'));

        // Set language
        function setLanguage(lang) {
            currentLanguage = lang;
            
            // Update active button
            langEl.classList.toggle('active', lang === 'el');
            langEn.classList.toggle('active', lang === 'en');
            
            // Update all elements with data-el and data-en attributes
            document.querySelectorAll('[data-el][data-en]').forEach(el => {
                el.textContent = el.getAttribute(`data-${lang}`);
            });
            
            // Update placeholders
            document.querySelectorAll('[data-el-placeholder][data-en-placeholder]').forEach(el => {
                el.setAttribute('placeholder', el.getAttribute(`data-${lang}-placeholder`));
            });
            
            // Update status text
            if (statusEl.textContent.includes('GPS')) {
                statusEl.textContent = userPosition ? translations[lang].active : translations[lang].waiting;
            }
            
            // Update accuracy 
            if (currentAccuracy !== null) {
                accuracyEl.textContent = `${translations[lang].accuracy}±${currentAccuracy.toFixed(2)}${translations[lang].meters}`;
            } else {
                accuracyEl.textContent = translations[lang].notAvailable;
            }
            
            // Update toggle button text
            toggleBtn.textContent = arVisible ? translations[lang].hideAR : translations[lang].showAR;
            
            // Update datetime format
            updateDateTime();
        }

        // Handle KML file upload
        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            statusEl.textContent = translations[currentLanguage].loading;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const polygons = parseKML(e.target.result);
                    if (!polygons || polygons.length === 0) {
                        showError(translations[currentLanguage].noPolygons);
                    } else {
                        renderPolygons(polygons);
                        statusEl.textContent = translations[currentLanguage].loaded;
                    }
                } catch (err) {
                    showError(translations[currentLanguage].parseError + err.message);
                }
            };
            reader.onerror = function() {
                showError(translations[currentLanguage].readError);
            };
            reader.readAsText(file);
        }

        // Handle KML URL loading
        function handleUrlLoad() {
            const url = urlInput.value.trim();
            if (!url) {
                showError(translations[currentLanguage].urlRequired);
                return;
            }
            statusEl.textContent = translations[currentLanguage].loading;
            fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    return response.text();
                })
                .then(kmlText => {
                    try {
                        const polygons = parseKML(kmlText);
                        if (!polygons || polygons.length === 0) {
                            showError(translations[currentLanguage].noPolygons);
                        } else {
                            renderPolygons(polygons);
                            statusEl.textContent = translations[currentLanguage].loaded;
                        }
                    } catch (err) {
                        showError(translations[currentLanguage].parseError + err.message);
                    }
                })
                .catch(error => {
                    showError(translations[currentLanguage].downloadError + error.message);
                });
        }

        // Parse KML to extract polygons, lines, points
        function parseKML(kmlText) {
            const parser = new DOMParser();
            const kmlDoc = parser.parseFromString(kmlText, "text/xml");
            const parserError = kmlDoc.getElementsByTagName('parsererror');
            if (parserError.length > 0) throw new Error(translations[currentLanguage].invalidXml);
            const polygons = [];
            const placemarks = kmlDoc.getElementsByTagName('Placemark');
            for (let i = 0; i < placemarks.length; i++) {
                const placemark = placemarks[i];
                const nameEl = placemark.getElementsByTagName('name')[0];
                const name = nameEl ? nameEl.textContent : "Στοιχείο " + (i + 1);
                // Πολύγωνα
                const polygonElements = placemark.getElementsByTagName('Polygon');
                for (let j = 0; j < polygonElements.length; j++) {
                    const polygon = polygonElements[j];
                    const coordsElements = polygon.getElementsByTagName('coordinates');
                    if (coordsElements.length > 0) {
                        const coordsText = coordsElements[0].textContent.trim();
                        const coords = parseCoordinateString(coordsText);
                        if (coords.length > 2) {
                            polygons.push({type: 'polygon', name, points: coords});
                        }
                    }
                }
                // Γραμμές
                const lineElements = placemark.getElementsByTagName('LineString');
                for (let j = 0; j < lineElements.length; j++) {
                    const line = lineElements[j];
                    const coordsElements = line.getElementsByTagName('coordinates');
                    if (coordsElements.length > 0) {
                        const coordsText = coordsElements[0].textContent.trim();
                        const coords = parseCoordinateString(coordsText);
                        if (coords.length > 1) {
                            polygons.push({type: 'line', name, points: coords});
                        }
                    }
                }
                // Σημεία
                const pointElements = placemark.getElementsByTagName('Point');
                for (let j = 0; j < pointElements.length; j++) {
                    const point = pointElements[j];
                    const coordsElements = point.getElementsByTagName('coordinates');
                    if (coordsElements.length > 0) {
                        const coordsText = coordsElements[0].textContent.trim();
                        const coords = parseCoordinateString(coordsText);
                        if (coords.length > 0) {
                            polygons.push({type: 'point', name, points: coords});
                        }
                    }
                }
            }
            return polygons;
        }
        
        function parseCoordinateString(coordsText) {
            const coordinates = [];
            const coordPairs = coordsText.split(/\s+/);
            for (let i = 0; i < coordPairs.length; i++) {
                const pair = coordPairs[i].trim();
                if (!pair) continue;
                const coords = pair.split(',');
                if (coords.length >= 2) {
                    const lon = parseFloat(coords[0]);
                    const lat = parseFloat(coords[1]);
                    if (!isNaN(lon) && !isNaN(lat)) {
                        coordinates.push({ lat, lon });
                    }
                }
            }
            return coordinates;
        }

        // Render polygons, lines, points
        function renderPolygons(polygons) {
            kmlContainer.innerHTML = '';
            polygons.forEach((polygon, index) => {
                if (polygon.type === 'polygon') {
                    renderPolygon(polygon, index);
                } else if (polygon.type === 'line') {
                    renderLine(polygon, index);
                } else if (polygon.type === 'point') {
                    renderPoint(polygon, index);
                }
            });
        }
        
        function renderPolygon(polygon, index) {
            const points = polygon.points;
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                const line = document.createElement('a-entity');
                line.setAttribute('gps-entity-place', `latitude: ${p1.lat}; longitude: ${p1.lon}`);
                line.setAttribute('line', {
                    start: '0 0 0',
                    end: `${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).x} 0 ${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).z}`,
                    color: '#4361EE', // Primary color
                    opacity: 0.85,
                    width: 6
                });
                kmlContainer.appendChild(line);
            }
            // Calculate center point
            let avgLat = 0, avgLon = 0;
            points.forEach(p => { avgLat += p.lat; avgLon += p.lon; });
            avgLat /= points.length;
            avgLon /= points.length;
            // Calculate maximum distance
            let maxDistance = 0;
            points.forEach(p => {
                const distance = geoDistance(avgLat, avgLon, p.lat, p.lon);
                if (distance > maxDistance) maxDistance = distance;
            });
            // Create polygon fill
            const fill = document.createElement('a-entity');
            fill.setAttribute('gps-entity-place', `latitude: ${avgLat}; longitude: ${avgLon}`);
            fill.setAttribute('geometry', {
                primitive: 'plane',
                width: maxDistance * 2,
                height: maxDistance * 2
            });
            fill.setAttribute('material', {
                color: '#4CC9F0', // Secondary color
                opacity: 0.25,
                transparent: true,
                side: 'double'
            });
            fill.setAttribute('rotation', '-90 0 0');
            kmlContainer.appendChild(fill);
            // Add text label
            const text = document.createElement('a-text');
            text.setAttribute('gps-entity-place', `latitude: ${avgLat}; longitude: ${avgLon}`);
            text.setAttribute('value', polygon.name);
            text.setAttribute('scale', '7 7 7');
            text.setAttribute('look-at', '[gps-camera]');
            text.setAttribute('align', 'center');
            text.setAttribute('color', '#4361EE'); // Primary color
            text.setAttribute('position', '0 12 0');
            kmlContainer.appendChild(text);
        }
        
        function renderLine(line, index) {
            const points = line.points;
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];
                const lineEntity = document.createElement('a-entity');
                lineEntity.setAttribute('gps-entity-place', `latitude: ${p1.lat}; longitude: ${p1.lon}`);
                lineEntity.setAttribute('line', {
                    start: '0 0 0',
                    end: `${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).x} 0 ${geoToMeters(p1.lat, p1.lon, p2.lat, p2.lon).z}`,
                    color: '#F72585', // Accent color
                    opacity: 0.9,
                    width: 4
                });
                kmlContainer.appendChild(lineEntity);
            }
            // Add label at midpoint
            if (points.length > 0) {
                const midPoint = points[Math.floor(points.length / 2)];
                const text = document.createElement('a-text');
                text.setAttribute('gps-entity-place', `latitude: ${midPoint.lat}; longitude: ${midPoint.lon}`);
                text.setAttribute('value', line.name);
                text.setAttribute('scale', '6 6 6');
                text.setAttribute('look-at', '[gps-camera]');
                text.setAttribute('align', 'center');
                text.setAttribute('color', '#4361EE'); // Primary color
                text.setAttribute('position', '0 10 0');
                kmlContainer.appendChild(text);
            }
        }
        
        function renderPoint(point, index) {
            if (point.points.length > 0) {
                const p = point.points[0];
                const sphere = document.createElement('a-sphere');
                sphere.setAttribute('gps-entity-place', `latitude: ${p.lat}; longitude: ${p.lon}`);
                sphere.setAttribute('color', '#F72585'); // Accent color
                sphere.setAttribute('radius', '2.5');
                sphere.setAttribute('position', '0 0 0');
                kmlContainer.appendChild(sphere);
                const text = document.createElement('a-text');
                text.setAttribute('gps-entity-place', `latitude: ${p.lat}; longitude: ${p.lon}`);
                text.setAttribute('value', point.name);
                text.setAttribute('scale', '5 5 5');
                text.setAttribute('look-at', '[gps-camera]');
                text.setAttribute('align', 'center');
                text.setAttribute('color', '#4361EE'); // Primary color
                text.setAttribute('position', '0 8 0');
                kmlContainer.appendChild(text);
            }
        }
        
        // Toggle AR visibility
        function toggleARVisibility() {
            arVisible = !arVisible;
            kmlContainer.setAttribute('visible', arVisible);
            toggleBtn.textContent = arVisible ? 
                translations[currentLanguage].hideAR : 
                translations[currentLanguage].showAR;
        }
        
        // Reset AR scene
        function resetAR() {
            kmlContainer.innerHTML = '';
            statusEl.textContent = translations[currentLanguage].reset;
        }
        
        // Show error message
        function showError(message) {
            errorMessageEl.textContent = message;
            errorMessageEl.style.display = 'block';
            setTimeout(() => {
                errorMessageEl.style.display = 'none';
            }, 5000);
            statusEl.textContent = translations[currentLanguage].error;
        }
        
        // Convert geo coordinates to meters
        function geoToMeters(lat1, lon1, lat2, lon2) {
            const R = 6378137;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const distance = R * c;
            const bearing = Math.atan2(
                Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180),
                Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
                Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon)
            );
            const x = distance * Math.sin(bearing);
            const z = distance * Math.cos(bearing);
            return { x, y: 0, z };
        }
        
        function geoDistance(lat1, lon1, lat2, lon2) {
            const R = 6378137;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // AR scene initialization and location handling
        document.addEventListener('DOMContentLoaded', () => {
            const camera = document.querySelector('a-camera');
            camera.addEventListener('gps-camera-update-position', e => {
                userPosition = e.detail.position;
                statusEl.textContent = translations[currentLanguage].active;
                let acc = null;
                if (e.detail.position && e.detail.position.accuracy !== undefined) {
                    acc = e.detail.position.accuracy;
                } else if (e.detail.accuracy !== undefined) {
                    acc = e.detail.accuracy;
                }
                if (acc !== null) {
                    currentAccuracy = acc;
                    accuracyEl.textContent = `${translations[currentLanguage].accuracy}±${currentAccuracy.toFixed(2)}${translations[currentLanguage].meters}`;
                    
                    // Set appropriate color class based on accuracy
                    accuracyEl.className = ''; // Remove existing classes
                    if (currentAccuracy <= 10) {
                        accuracyEl.classList.add('status-good');
                    } else if (currentAccuracy <= 20) {
                        accuracyEl.classList.add('status-medium');
                    } else {
                        accuracyEl.classList.add('status-bad');
                    }
                } else {
                    accuracyEl.textContent = translations[currentLanguage].notAvailable;
                    accuracyEl.className = '';
                }
            });
        });
    </script>
</body>
</html>
